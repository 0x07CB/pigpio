
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
   <meta name="description" content="Raspberry Pi Reg. C GPIO library and Python GPIO module and shell command utilities to control the GPIO, including SPI, I2C, and serial links." />
   <meta name="keywords" content="raspberry, pi, C, Python, GPIO, library, shell, command, utilities, module, SPI, I2C, serial" />
   <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
   <title>pigpio library</title>
   <link rel="stylesheet" type="text/css" href="scripts/index.css">
   <link rel="icon" href="favicon.ico" type="image/x-icon">
   <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
</head>
<body>

<table style="padding:0px; border:0px; margin:0px; width:780px; background-color:#e0e0e0;">
<td style="background:#EAF2E6 url('images/sidebar.gif') repeat-y; width:35px; height:100%"></td>
<td>
<table>
<div style="background:url('images/topbar.gif') repeat-x; height: 70px; font-size:1.5em; vertical-align: top;"><a href="index.html"><img src="images/pigpio-logo.gif" border="0" /></a>pigpio library</div>
</table>
<table><div>
<td><img src="images/rf-rx.jpg" width="250"></td>
<td><img src="images/stepper.jpg" width="250"></td>
<td><img src="images/keypad.jpg" width="250"></td>
</div></table>
<table>
<td style="vertical-align: top; background-color: #98bf21;"><a class="l1" href="index.html">pigpio</a>
<a class="l1" href="cif.html">pigpio C I/F</a>
<a class="l1" href="pigpiod.html">pigpiod</a>
<a class="l1" href="pdif2.html">pigpiod C I/F</a>
<a class="l1" href="python.html">Python</a>
<a class="l1" href="pigs.html">pigs</a>
<a class="l1" href="piscope.html">piscope</a>
<a class="l1" href="misc.html">Misc</a>
<a class="l1" href="examples.html">Examples</a>
<a class="l1" href="download.html">Download</a>
<a class="l1" href="faq.html">FAQ</a>
<a class="l1" href="sitemap.html">Site Map</a>
</td>
<td><center><h2>pigpiod C Interface</h2></center><br><br>pigpiod_if2 is a C library for the Raspberry which allows control
of the GPIO via the socket interface to the pigpio daemon.<br>
<h3>Features</h3>o hardware timed PWM on any of GPIO 0-31
<br><br>o hardware timed servo pulses on any of GPIO 0-31
<br><br>o callbacks when any of GPIO 0-31 change state
<br><br>o callbacks at timed intervals
<br><br>o reading/writing all of the GPIO in a bank as one operation
<br><br>o individually setting GPIO modes, reading and writing
<br><br>o notifications when any of GPIO 0-31 change state
<br><br>o the construction of output waveforms with microsecond timing
<br><br>o rudimentary permission control over GPIO
<br><br>o a simple interface to start and stop new threads
<br><br>o I2C, SPI, and serial link wrappers
<br><br>o creating and running scripts on the pigpio daemon
<h3>GPIO</h3>ALL GPIO are identified by their Broadcom number.
<h3>Notes</h3>The PWM and servo pulses are timed using the DMA and PWM/PCM peripherals.
<h3>Usage</h3>Include &lt;pigpiod_if2.h&gt; in your source files.
<br><br>Assuming your source is in prog.c use the following command to build
<br><br><code>gcc&nbsp;-Wall&nbsp;-pthread&nbsp;-o&nbsp;prog&nbsp;prog.c&nbsp;-lpigpiod_if2&nbsp;-lrt<br></code><br><br>to run make sure the pigpio daemon is running
<br><br><code>sudo&nbsp;pigpiod<br><br>&nbsp;./prog&nbsp;#&nbsp;sudo&nbsp;is&nbsp;not&nbsp;required&nbsp;to&nbsp;run&nbsp;programs&nbsp;linked&nbsp;to&nbsp;pigpiod_if2<br></code><br><br>For examples see x_pigpiod_if2.c within the pigpio archive file.
<h3>Notes</h3>All the functions which return an int return &lt; 0 on error
<h2>OVERVIEW</h2><table border="0" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td></td></tr><tr><td><b>ESSENTIAL
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#pigpio_start">pigpio_start</a></td><td>              Connects to a pigpio daemon
</td></tr><tr><td><a href="#pigpio_stop">pigpio_stop</a></td><td>               Disconnects from a pigpio daemon
</td></tr><tr><td></td><td></td></tr><tr><td><b>BASIC
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_mode">set_mode</a></td><td>                  Set a GPIO mode
</td></tr><tr><td><a href="#get_mode">get_mode</a></td><td>                  Get a GPIO mode
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_pull_up_down">set_pull_up_down</a></td><td>          Set/clear GPIO pull up/down resistor
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpio_read">gpio_read</a></td><td>                 Read a GPIO
</td></tr><tr><td><a href="#gpio_write">gpio_write</a></td><td>                Write a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>PWM (overrides servo commands on same GPIO)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_PWM_dutycycle">set_PWM_dutycycle</a></td><td>         Start/stop PWM pulses on a GPIO
</td></tr><tr><td><a href="#set_PWM_frequency">set_PWM_frequency</a></td><td>         Configure PWM frequency for a GPIO
</td></tr><tr><td><a href="#set_PWM_range">set_PWM_range</a></td><td>             Configure PWM range for a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_PWM_dutycycle">get_PWM_dutycycle</a></td><td>         Get the PWM dutycycle in use on a GPIO
</td></tr><tr><td><a href="#get_PWM_frequency">get_PWM_frequency</a></td><td>         Get configured PWM frequency for a GPIO
</td></tr><tr><td><a href="#get_PWM_range">get_PWM_range</a></td><td>             Get configured PWM range for a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_PWM_real_range">get_PWM_real_range</a></td><td>        Get underlying PWM range for a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>Servo (overrides PWM commands on same GPIO)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_servo_pulsewidth">set_servo_pulsewidth</a></td><td>      Start/stop servo pulses on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_servo_pulsewidth">get_servo_pulsewidth</a></td><td>      Get the servo pulsewidth in use on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>INTERMEDIATE
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpio_trigger">gpio_trigger</a></td><td>              Send a trigger pulse to a GPIO.
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_watchdog">set_watchdog</a></td><td>              Set a watchdog on a GPIO.
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#read_bank_1">read_bank_1</a></td><td>               Read all GPIO in bank 1
</td></tr><tr><td><a href="#read_bank_2">read_bank_2</a></td><td>               Read all GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#clear_bank_1">clear_bank_1</a></td><td>              Clear selected GPIO in bank 1
</td></tr><tr><td><a href="#clear_bank_2">clear_bank_2</a></td><td>              Clear selected GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_bank_1">set_bank_1</a></td><td>                Set selected GPIO in bank 1
</td></tr><tr><td><a href="#set_bank_2">set_bank_2</a></td><td>                Set selected GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#callback">callback</a></td><td>                  Create GPIO level change callback
</td></tr><tr><td><a href="#callback_ex">callback_ex</a></td><td>               Create GPIO level change callback, extended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#callback_cancel">callback_cancel</a></td><td>           Cancel a callback
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wait_for_edge">wait_for_edge</a></td><td>             Wait for GPIO level change
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#start_thread">start_thread</a></td><td>              Start a new thread
</td></tr><tr><td><a href="#stop_thread">stop_thread</a></td><td>               Stop a previously started thread
</td></tr><tr><td></td><td></td></tr><tr><td><b>ADVANCED
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#notify_open">notify_open</a></td><td>               Request a notification handle
</td></tr><tr><td><a href="#notify_begin">notify_begin</a></td><td>              Start notifications for selected GPIO
</td></tr><tr><td><a href="#notify_pause">notify_pause</a></td><td>              Pause notifications
</td></tr><tr><td><a href="#notify_close">notify_close</a></td><td>              Close a notification
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#hardware_clock">hardware_clock</a></td><td>            Start hardware clock on supported GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#hardware_PWM">hardware_PWM</a></td><td>              Start hardware PWM on supported GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_glitch_filter">set_glitch_filter</a></td><td>         Set a glitch filter on a GPIO
</td></tr><tr><td><a href="#set_noise_filter">set_noise_filter</a></td><td>          Set a noise filter on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_pad_strength">set_pad_strength</a></td><td>          Sets a pads drive strength
</td></tr><tr><td><a href="#get_pad_strength">get_pad_strength</a></td><td>          Gets a pads drive strength
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#shell_">shell_</a></td><td>                    Executes a shell command
</td></tr><tr><td></td><td></td></tr><tr><td><b>Custom
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#custom_1">custom_1</a></td><td>                  User custom function 1
</td></tr><tr><td><a href="#custom_2">custom_2</a></td><td>                  User custom function 2
</td></tr><tr><td></td><td></td></tr><tr><td><b>Events
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#event_callback">event_callback</a></td><td>           Sets a callback for an event
</td></tr><tr><td><a href="#event_callback_ex">event_callback_ex</a></td><td>        Sets a callback for an event, extended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#event_callback_cancel">event_callback_cancel</a></td><td>    Cancel an event callback
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#event_trigger">event_trigger</a></td><td>            Triggers an event
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wait_for_event">wait_for_event</a></td><td>           Wait for an event
</td></tr><tr><td></td><td></td></tr><tr><td><b>Scripts
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#store_script">store_script</a></td><td>              Store a script
</td></tr><tr><td><a href="#run_script">run_script</a></td><td>                Run a stored script
</td></tr><tr><td><a href="#update_script">update_script</a></td><td>             Set a scripts parameters
</td></tr><tr><td><a href="#script_status">script_status</a></td><td>             Get script status and parameters
</td></tr><tr><td><a href="#stop_script">stop_script</a></td><td>               Stop a running script
</td></tr><tr><td><a href="#delete_script">delete_script</a></td><td>             Delete a stored script
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_open">i2c_open</a></td><td>                  Opens an I2C device
</td></tr><tr><td><a href="#i2c_close">i2c_close</a></td><td>                 Closes an I2C device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_write_quick">i2c_write_quick</a></td><td>           smbus write quick
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_byte">i2c_read_byte</a></td><td>             smbus read byte
</td></tr><tr><td><a href="#i2c_write_byte">i2c_write_byte</a></td><td>            smbus write byte
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_byte_data">i2c_read_byte_data</a></td><td>        smbus read byte data
</td></tr><tr><td><a href="#i2c_write_byte_data">i2c_write_byte_data</a></td><td>       smbus write byte data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_word_data">i2c_read_word_data</a></td><td>        smbus read word data
</td></tr><tr><td><a href="#i2c_write_word_data">i2c_write_word_data</a></td><td>       smbus write word data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_block_data">i2c_read_block_data</a></td><td>       smbus read block data
</td></tr><tr><td><a href="#i2c_write_block_data">i2c_write_block_data</a></td><td>      smbus write block data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_i2c_block_data">i2c_read_i2c_block_data</a></td><td>   smbus read I2C block data
</td></tr><tr><td><a href="#i2c_write_i2c_block_data">i2c_write_i2c_block_data</a></td><td>  smbus write I2C block data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_device">i2c_read_device</a></td><td>           Reads the raw I2C device
</td></tr><tr><td><a href="#i2c_write_device">i2c_write_device</a></td><td>          Writes the raw I2C device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_process_call">i2c_process_call</a></td><td>          smbus process call
</td></tr><tr><td><a href="#i2c_block_process_call">i2c_block_process_call</a></td><td>    smbus block process call
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_zip">i2c_zip</a></td><td>                   Performs multiple I2C transactions
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C BIT BANG
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_i2c_open">bb_i2c_open</a></td><td>               Opens GPIO for bit banging I2C
</td></tr><tr><td><a href="#bb_i2c_close">bb_i2c_close</a></td><td>              Closes GPIO for bit banging I2C
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_i2c_zip">bb_i2c_zip</a></td><td>                Performs bit banged I2C transactions
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C/SPI SLAVE
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bsc_xfer">bsc_xfer</a></td><td>                  I2C/SPI as slave transfer
</td></tr><tr><td><a href="#bsc_i2c">bsc_i2c</a></td><td>                   I2C as slave transfer
</td></tr><tr><td></td><td></td></tr><tr><td><b>SERIAL
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_open">serial_open</a></td><td>               Opens a serial device
</td></tr><tr><td><a href="#serial_close">serial_close</a></td><td>              Closes a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_read_byte">serial_read_byte</a></td><td>          Reads a byte from a serial device
</td></tr><tr><td><a href="#serial_write_byte">serial_write_byte</a></td><td>         Writes a byte to a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_read">serial_read</a></td><td>               Reads bytes from a serial device
</td></tr><tr><td><a href="#serial_write">serial_write</a></td><td>              Writes bytes to a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_data_available">serial_data_available</a></td><td>     Returns number of bytes ready to be read
</td></tr><tr><td></td><td></td></tr><tr><td><b>SERIAL BIT BANG (read only)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_serial_read_open">bb_serial_read_open</a></td><td>       Opens a GPIO for bit bang serial reads
</td></tr><tr><td><a href="#bb_serial_read_close">bb_serial_read_close</a></td><td>      Closes a GPIO for bit bang serial reads
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_serial_invert">bb_serial_invert</a></td><td>          Invert serial logic (1 invert, 0 normal)
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_serial_read">bb_serial_read</a></td><td>            Reads bit bang serial data from a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>SPI
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#spi_open">spi_open</a></td><td>                  Opens a SPI device
</td></tr><tr><td><a href="#spi_close">spi_close</a></td><td>                 Closes a SPI device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#spi_read">spi_read</a></td><td>                  Reads bytes from a SPI device
</td></tr><tr><td><a href="#spi_write">spi_write</a></td><td>                 Writes bytes to a SPI device
</td></tr><tr><td><a href="#spi_xfer">spi_xfer</a></td><td>                  Transfers bytes with a SPI device
</td></tr><tr><td></td><td></td></tr><tr><td><b>SPI BIT BANG
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_spi_open">bb_spi_open</a></td><td>               Opens GPIO for bit banging SPI
</td></tr><tr><td><a href="#bb_spi_close">bb_spi_close</a></td><td>              Closes GPIO for bit banging SPI
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_spi_xfer">bb_spi_xfer</a></td><td>               Transfers bytes with bit banging SPI
</td></tr><tr><td></td><td></td></tr><tr><td><b>FILES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_open">file_open</a></td><td>                 Opens a file
</td></tr><tr><td><a href="#file_close">file_close</a></td><td>                Closes a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_read">file_read</a></td><td>                 Reads bytes from a file
</td></tr><tr><td><a href="#file_write">file_write</a></td><td>                Writes bytes to a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_seek">file_seek</a></td><td>                 Seeks to a position within a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_list">file_list</a></td><td>                 List files which match a pattern
</td></tr><tr><td></td><td></td></tr><tr><td><b>WAVES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_clear">wave_clear</a></td><td>                Deletes all waveforms
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_add_new">wave_add_new</a></td><td>              Starts a new waveform
</td></tr><tr><td><a href="#wave_add_generic">wave_add_generic</a></td><td>          Adds a series of pulses to the waveform
</td></tr><tr><td><a href="#wave_add_serial">wave_add_serial</a></td><td>           Adds serial data to the waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_create">wave_create</a></td><td>               Creates a waveform from added data
</td></tr><tr><td><a href="#wave_create_and_pad">wave_create_and_pad</a></td><td>       Creates a waveform of fixed size from added data
</td></tr><tr><td><a href="#wave_delete">wave_delete</a></td><td>               Deletes one or more waveforms
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_send_once">wave_send_once</a></td><td>            Transmits a waveform once
</td></tr><tr><td><a href="#wave_send_repeat">wave_send_repeat</a></td><td>          Transmits a waveform repeatedly
</td></tr><tr><td><a href="#wave_send_using_mode">wave_send_using_mode</a></td><td>      Transmits a waveform in the chosen mode
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_chain">wave_chain</a></td><td>                Transmits a chain of waveforms
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_tx_at">wave_tx_at</a></td><td>                Returns the current transmitting waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_tx_busy">wave_tx_busy</a></td><td>              Checks to see if the waveform has ended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_tx_stop">wave_tx_stop</a></td><td>              Aborts the current waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_get_cbs">wave_get_cbs</a></td><td>              Length in cbs of the current waveform
</td></tr><tr><td><a href="#wave_get_high_cbs">wave_get_high_cbs</a></td><td>         Length of longest waveform so far
</td></tr><tr><td><a href="#wave_get_max_cbs">wave_get_max_cbs</a></td><td>          Absolute maximum allowed cbs
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_get_micros">wave_get_micros</a></td><td>           Length in micros of the current waveform
</td></tr><tr><td><a href="#wave_get_high_micros">wave_get_high_micros</a></td><td>      Length of longest waveform so far
</td></tr><tr><td><a href="#wave_get_max_micros">wave_get_max_micros</a></td><td>       Absolute maximum allowed micros
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_get_pulses">wave_get_pulses</a></td><td>           Length in pulses of the current waveform
</td></tr><tr><td><a href="#wave_get_high_pulses">wave_get_high_pulses</a></td><td>      Length of longest waveform so far
</td></tr><tr><td><a href="#wave_get_max_pulses">wave_get_max_pulses</a></td><td>       Absolute maximum allowed pulses
</td></tr><tr><td></td><td></td></tr><tr><td><b>UTILITIES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_current_tick">get_current_tick</a></td><td>          Get current tick (microseconds)
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_hardware_revision">get_hardware_revision</a></td><td>     Get hardware revision
</td></tr><tr><td><a href="#get_pigpio_version">get_pigpio_version</a></td><td>        Get the pigpio version
</td></tr><tr><td><a href="#pigpiod_if_version">pigpiod_if_version</a></td><td>        Get the pigpiod_if2 version
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#pigpio_error">pigpio_error</a></td><td>              Get a text description of an error code.
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#time_sleep">time_sleep</a></td><td>                Sleeps for a float number of seconds
</td></tr><tr><td><a href="#time_time">time_time</a></td><td>                 Float number of seconds since the epoch
</td></tr><tr><td></td><td></td></tr></tbody></table><h2>FUNCTIONS</h2><h3><a name="time_time"></a><a href="#double"><small>double</small></a> time_time<small>(void)</small></h3>
Return the current time in seconds since the Epoch.
<h3><a name="time_sleep"></a><a href="#void"><small>void</small></a> time_sleep<small>(<a href="#double">double</a> <a href="#seconds">seconds</a>)</small></h3>
Delay execution for a given number of seconds.
<br><br><code>seconds:&nbsp;the&nbsp;number&nbsp;of&nbsp;seconds&nbsp;to&nbsp;delay.<br></code><h3><a name="pigpio_error"></a><a href="#char"><small>char</small></a> *pigpio_error<small>(<a href="#int">int</a> <a href="#errnum">errnum</a>)</small></h3>
Return a text description for an error code.
<br><br><code>errnum:&nbsp;the&nbsp;error&nbsp;code.<br></code><h3><a name="pigpiod_if_version"></a><a href="#unsigned"><small>unsigned</small></a> pigpiod_if_version<small>(void)</small></h3>
Return the pigpiod_if2 version.
<h3><a name="start_thread"></a><a href="#pthread_t"><small>pthread_t</small></a> *start_thread<small>(<a href="#gpioThreadFunc_t">gpioThreadFunc_t</a> <a href="#thread_func">thread_func</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Starts a new thread of execution with thread_func as the main routine.
<br><br><code>thread_func:&nbsp;the&nbsp;main&nbsp;function&nbsp;for&nbsp;the&nbsp;new&nbsp;thread.<br>&nbsp;&nbsp;&nbsp;userdata:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;an&nbsp;arbitrary&nbsp;argument.<br></code><br><br>Returns a pointer to pthread_t if OK, otherwise NULL.
<br><br>The function is passed the single argument userdata.
<br><br>The thread can be cancelled by passing the pointer to pthread_t to
<a href="#stop_thread">stop_thread</a>.
<h3><a name="stop_thread"></a><a href="#void"><small>void</small></a> stop_thread<small>(<a href="#pthread_t">pthread_t</a> <a href="#*pth">*pth</a>)</small></h3>
Cancels the thread pointed at by pth.
<br><br><code>pth:&nbsp;the&nbsp;thread&nbsp;to&nbsp;be&nbsp;stopped.<br></code><br><br>No value is returned.
<br><br>The thread to be stopped should have been started with <a href="#start_thread">start_thread</a>.
<h3><a name="pigpio_start"></a><a href="#int"><small>int</small></a> pigpio_start<small>(<a href="#char">char</a> <a href="#*addrStr">*addrStr</a>, <a href="#char">char</a> <a href="#*portStr">*portStr</a>)</small></h3>
Connect to the pigpio daemon.  Reserving command and
notification streams.
<br><br><code>addrStr:&nbsp;specifies&nbsp;the&nbsp;host&nbsp;or&nbsp;IP&nbsp;address&nbsp;of&nbsp;the&nbsp;Pi&nbsp;running&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pigpio&nbsp;daemon.&nbsp;&nbsp;It&nbsp;may&nbsp;be&nbsp;NULL&nbsp;in&nbsp;which&nbsp;case&nbsp;localhost<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;used&nbsp;unless&nbsp;overridden&nbsp;by&nbsp;the&nbsp;PIGPIO_ADDR&nbsp;environment<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable.<br><br>portStr:&nbsp;specifies&nbsp;the&nbsp;port&nbsp;address&nbsp;used&nbsp;by&nbsp;the&nbsp;Pi&nbsp;running&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pigpio&nbsp;daemon.&nbsp;&nbsp;It&nbsp;may&nbsp;be&nbsp;NULL&nbsp;in&nbsp;which&nbsp;case&nbsp;"8888"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;used&nbsp;unless&nbsp;overridden&nbsp;by&nbsp;the&nbsp;PIGPIO_PORT&nbsp;environment<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variable.<br></code><br><br>Returns an integer value greater than or equal to zero if OK.
<br><br>This value is passed to the GPIO routines to specify the Pi
to be operated on.
<h3><a name="pigpio_stop"></a><a href="#void"><small>void</small></a> pigpio_stop<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
Terminates the connection to a pigpio daemon and releases
resources used by the library.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="set_mode"></a><a href="#int"><small>int</small></a> set_mode<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#mode">mode</a>)</small></h3>
Set the GPIO mode.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>gpio:&nbsp;0-53.<br>mode:&nbsp;PI_INPUT,&nbsp;PI_OUTPUT,&nbsp;PI_ALT0,&nbsp;PI_ALT1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PI_ALT2,&nbsp;PI_ALT3,&nbsp;PI_ALT4,&nbsp;PI_ALT5.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_MODE,
or PI_NOT_PERMITTED.
<h3><a name="get_mode"></a><a href="#int"><small>int</small></a> get_mode<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>)</small></h3>
Get the GPIO mode.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>gpio:&nbsp;0-53.<br></code><br><br>Returns the GPIO mode if OK, otherwise PI_BAD_GPIO.
<h3><a name="set_pull_up_down"></a><a href="#int"><small>int</small></a> set_pull_up_down<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#pud">pud</a>)</small></h3>
Set or clear the GPIO pull-up/down resistor.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>gpio:&nbsp;0-53.<br>&nbsp;pud:&nbsp;PI_PUD_UP,&nbsp;PI_PUD_DOWN,&nbsp;PI_PUD_OFF.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_PUD,
or PI_NOT_PERMITTED.
<h3><a name="gpio_read"></a><a href="#int"><small>int</small></a> gpio_read<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>)</small></h3>
Read the GPIO level.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>gpio:0-53.<br></code><br><br>Returns the GPIO level if OK, otherwise PI_BAD_GPIO.
<h3><a name="gpio_write"></a><a href="#int"><small>int</small></a> gpio_write<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#level">level</a>)</small></h3>
Write the GPIO level.
<br><br><code>&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;gpio:&nbsp;0-53.<br>level:&nbsp;0,&nbsp;1.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_LEVEL,
or PI_NOT_PERMITTED.
<br><br>Notes
<br><br>If PWM or servo pulses are active on the GPIO they are switched off.
<h3><a name="set_PWM_dutycycle"></a><a href="#int"><small>int</small></a> set_PWM_dutycycle<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#dutycycle">dutycycle</a>)</small></h3>
Start (non-zero dutycycle) or stop (0) PWM pulses on the GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>dutycycle:&nbsp;0-range&nbsp;(range&nbsp;defaults&nbsp;to&nbsp;255).<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_DUTYCYCLE,
or PI_NOT_PERMITTED.
Notes
<br><br>The <a href="#set_PWM_range">set_PWM_range</a> function may be used to change the
default range of 255.
<h3><a name="get_PWM_dutycycle"></a><a href="#int"><small>int</small></a> get_PWM_dutycycle<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Return the PWM dutycycle in use on a GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_PWM_GPIO.
<br><br>For normal PWM the dutycycle will be out of the defined range
for the GPIO (see <a href="#get_PWM_range">get_PWM_range</a>).
<br><br>If a hardware clock is active on the GPIO the reported dutycycle
will be 500000 (500k) out of 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported dutycycle
will be out of a 1000000 (1M).
<h3><a name="set_PWM_range"></a><a href="#int"><small>int</small></a> set_PWM_range<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#range">range</a>)</small></h3>
Set the range of PWM values to be used on the GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;range:&nbsp;25-40000.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_DUTYRANGE,
or PI_NOT_PERMITTED.
<br><br>Notes
<br><br>If PWM is currently active on the GPIO its dutycycle will be
scaled to reflect the new range.
<br><br>The real range, the number of steps between fully off and fully on
for each of the 18 available GPIO frequencies is
<br><br><code>&nbsp;&nbsp;25(#1),&nbsp;&nbsp;&nbsp;&nbsp;50(#2),&nbsp;&nbsp;&nbsp;100(#3),&nbsp;&nbsp;&nbsp;125(#4),&nbsp;&nbsp;&nbsp;&nbsp;200(#5),&nbsp;&nbsp;&nbsp;&nbsp;250(#6),<br>&nbsp;400(#7),&nbsp;&nbsp;&nbsp;500(#8),&nbsp;&nbsp;&nbsp;625(#9),&nbsp;&nbsp;&nbsp;800(#10),&nbsp;&nbsp;1000(#11),&nbsp;&nbsp;1250(#12),<br>2000(#13),&nbsp;2500(#14),&nbsp;4000(#15),&nbsp;5000(#16),&nbsp;10000(#17),&nbsp;20000(#18)<br></code><br><br>The real value set by set_PWM_range is (dutycycle * real range) / range.
<h3><a name="get_PWM_range"></a><a href="#int"><small>int</small></a> get_PWM_range<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Get the range of PWM values being used on the GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br></code><br><br>Returns the dutycycle range used for the GPIO if OK,
otherwise PI_BAD_USER_GPIO.
<br><br>If a hardware clock or hardware PWM is active on the GPIO the
reported range will be 1000000 (1M).
<h3><a name="get_PWM_real_range"></a><a href="#int"><small>int</small></a> get_PWM_real_range<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Get the real underlying range of PWM values being used on the GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br></code><br><br>Returns the real range used for the GPIO if OK,
otherwise PI_BAD_USER_GPIO.
<br><br>If a hardware clock is active on the GPIO the reported
real range will be 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported real range
will be approximately 250M divided by the set PWM frequency.
<h3><a name="set_PWM_frequency"></a><a href="#int"><small>int</small></a> set_PWM_frequency<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#frequency">frequency</a>)</small></h3>
Set the frequency (in Hz) of the PWM to be used on the GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>frequency:&nbsp;&gt;=0&nbsp;(Hz).<br></code><br><br>Returns the numerically closest frequency if OK, otherwise
PI_BAD_USER_GPIO or PI_NOT_PERMITTED.
<br><br>If PWM is currently active on the GPIO it will be switched
off and then back on at the new frequency.
<br><br>Each GPIO can be independently set to one of 18 different
PWM frequencies.
<br><br>The selectable frequencies depend upon the sample rate which
may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).  The
sample rate is set when the pigpio daemon is started.
<br><br>The frequencies for each sample rate are:
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hertz<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;40000&nbsp;20000&nbsp;10000&nbsp;8000&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1600<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1250&nbsp;&nbsp;1000&nbsp;&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;20000&nbsp;10000&nbsp;&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;800<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;625&nbsp;&nbsp;&nbsp;500&nbsp;&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;10000&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;400<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;313&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13<br>sample<br>&nbsp;rate<br>&nbsp;(us)&nbsp;&nbsp;5:&nbsp;&nbsp;8000&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;1600&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;320<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;&nbsp;160&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;313&nbsp;&nbsp;250&nbsp;&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;156&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;6<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10:&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;160<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;5<br></code><h3><a name="get_PWM_frequency"></a><a href="#int"><small>int</small></a> get_PWM_frequency<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Get the frequency of PWM being used on the GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br></code><br><br>For normal PWM the frequency will be that defined for the GPIO by
<a href="#set_PWM_frequency">set_PWM_frequency</a>.
<br><br>If a hardware clock is active on the GPIO the reported frequency
will be that set by <a href="#hardware_clock">hardware_clock</a>.
<br><br>If hardware PWM is active on the GPIO the reported frequency
will be that set by <a href="#hardware_PWM">hardware_PWM</a>.
<br><br>Returns the frequency (in hertz) used for the GPIO if OK,
otherwise PI_BAD_USER_GPIO.
<h3><a name="set_servo_pulsewidth"></a><a href="#int"><small>int</small></a> set_servo_pulsewidth<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#pulsewidth">pulsewidth</a>)</small></h3>
Start (500-2500) or stop (0) servo pulses on the GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;user_gpio:&nbsp;0-31.<br>pulsewidth:&nbsp;0&nbsp;(off),&nbsp;500&nbsp;(anti-clockwise)&nbsp;-&nbsp;2500&nbsp;(clockwise).<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_PULSEWIDTH or
PI_NOT_PERMITTED.
<br><br>The selected pulsewidth will continue to be transmitted until
changed by a subsequent call to set_servo_pulsewidth.
<br><br>The pulsewidths supported by servos varies and should probably be
determined by experiment. A value of 1500 should always be safe and
represents the mid-point of rotation.
<br><br>You can DAMAGE a servo if you command it to move beyond its limits.
<br><br>OTHER UPDATE RATES:
<br><br>This function updates servos at 50Hz.  If you wish to use a different
update frequency you will have to use the PWM functions.
<br><br><code>Update&nbsp;Rate&nbsp;(Hz)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;200&nbsp;&nbsp;400&nbsp;&nbsp;500<br>1E6/Hz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20000&nbsp;10000&nbsp;5000&nbsp;2500&nbsp;2000<br></code><br><br>Firstly set the desired PWM frequency using <a href="#set_PWM_frequency">set_PWM_frequency</a>.
<br><br>Then set the PWM range using <a href="#set_PWM_range">set_PWM_range</a> to 1E6/Hz.
Doing this allows you to use units of microseconds when setting
the servo pulsewidth.
<br><br>E.g. If you want to update a servo connected to GPIO 25 at 400Hz
<br><br><code>set_PWM_frequency(25,&nbsp;400);<br>set_PWM_range(25,&nbsp;2500);<br></code><br><br>Thereafter use the <a href="#set_PWM_dutycycle">set_PWM_dutycycle</a> function to move the servo,
e.g. set_PWM_dutycycle(25, 1500) will set a 1500 us pulse.<br>
<h3><a name="get_servo_pulsewidth"></a><a href="#int"><small>int</small></a> get_servo_pulsewidth<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Return the servo pulsewidth in use on a GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_SERVO_GPIO.
<h3><a name="notify_open"></a><a href="#int"><small>int</small></a> notify_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
Get a free notification handle.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>Returns a handle greater than or equal to zero if OK,
otherwise PI_NO_HANDLE.
<br><br>A notification is a method for being notified of GPIO state
changes via a pipe.
<br><br>Pipes are only accessible from the local machine so this function
serves no purpose if you are using the library from a remote machine.
The in-built (socket) notifications provided by <a href="#callback">callback</a>
should be used instead.
<br><br>Notifications for handle x will be available at the pipe
named /dev/pigpiox (where x is the handle number).
E.g. if the function returns 15 then the notifications must be
read from /dev/pigpio15.
<h3><a name="notify_begin"></a><a href="#int"><small>int</small></a> notify_begin<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Start notifications on a previously opened handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;0-31&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#notify_open">notify_open</a>)<br>&nbsp;&nbsp;bits:&nbsp;a&nbsp;mask&nbsp;indicating&nbsp;the&nbsp;GPIO&nbsp;to&nbsp;be&nbsp;notified.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br>The notification sends state changes for each GPIO whose
corresponding bit in bits is set.
<br><br>Each notification occupies 12 bytes in the fifo as follows:
<br><br><code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;seqno;<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;flags;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;tick;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;level;<br>}&nbsp;gpioReport_t;<br></code><br><br>seqno: starts at 0 each time the handle is opened and then increments
by one for each report.
<br><br>flags: three flags are defined, PI_NTFY_FLAGS_WDOG,
PI_NTFY_FLAGS_ALIVE, and PI_NTFY_FLAGS_EVENT.
<br><br>If bit 5 is set (PI_NTFY_FLAGS_WDOG) then bits 0-4 of the flags
indicate a GPIO which has had a watchdog timeout.
<br><br>If bit 6 is set (PI_NTFY_FLAGS_ALIVE) this indicates a keep alive
signal on the pipe/socket and is sent once a minute in the absence
of other notification activity.
<br><br>If bit 7 is set (PI_NTFY_FLAGS_EVENT) then bits 0-4 of the flags
indicate an event which has been triggered.
<br><br>tick: the number of microseconds since system boot.  It wraps around
after 1h12m.
<br><br>level: indicates the level of each GPIO.  If bit 1&lt;&lt;x is set then
GPIO x is high.
<h3><a name="notify_pause"></a><a href="#int"><small>int</small></a> notify_pause<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
Pause notifications on a previously opened handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;0-31&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#notify_open">notify_open</a>)<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br>Notifications for the handle are suspended until
<a href="#notify_begin">notify_begin</a> is called again.
<h3><a name="notify_close"></a><a href="#int"><small>int</small></a> notify_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
Stop notifications on a previously opened handle and
release the handle for reuse.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;0-31&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#notify_open">notify_open</a>)<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<h3><a name="set_watchdog"></a><a href="#int"><small>int</small></a> set_watchdog<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#timeout">timeout</a>)</small></h3>
Sets a watchdog for a GPIO.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;&nbsp;timeout:&nbsp;0-60000.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO
or PI_BAD_WDOG_TIMEOUT.
<br><br>The watchdog is nominally in milliseconds.
<br><br>Only one watchdog may be registered per GPIO.
<br><br>The watchdog may be cancelled by setting timeout to 0.
<br><br>Once a watchdog has been started callbacks for the GPIO will be
triggered every timeout interval after the last GPIO activity.
<br><br>The callback will receive the special level PI_TIMEOUT.
<h3><a name="set_glitch_filter"></a><a href="#int"><small>int</small></a> set_glitch_filter<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#steady">steady</a>)</small></h3>
Sets a glitch filter on a GPIO.
<br><br>Level changes on the GPIO are not reported unless the level
has been stable for at least <a href="#steady">steady</a> microseconds.  The
level is then reported.  Level changes of less than
<a href="#steady">steady</a> microseconds are ignored.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;steady:&nbsp;0-300000<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.
<br><br>This filter affects the GPIO samples returned to callbacks set up
with <a href="#callback">callback</a>, <a href="#callback_ex">callback_ex</a> and <a href="#wait_for_edge">wait_for_edge</a>.
<br><br>It does not affect levels read by <a href="#gpio_read">gpio_read</a>,
<a href="#read_bank_1">read_bank_1</a>, or <a href="#read_bank_2">read_bank_2</a>.
<br><br>Each (stable) edge will be timestamped <a href="#steady">steady</a> microseconds
after it was first detected.
<h3><a name="set_noise_filter"></a><a href="#int"><small>int</small></a> set_noise_filter<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#steady">steady</a>, <a href="#unsigned">unsigned</a> <a href="#active">active</a>)</small></h3>
Sets a noise filter on a GPIO.
<br><br>Level changes on the GPIO are ignored until a level which has
been stable for <a href="#steady">steady</a> microseconds is detected.  Level changes
on the GPIO are then reported for <a href="#active">active</a> microseconds after
which the process repeats.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;steady:&nbsp;0-300000<br>&nbsp;&nbsp;&nbsp;active:&nbsp;0-1000000<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.
<br><br>This filter affects the GPIO samples returned to callbacks set up
with <a href="#callback">callback</a>, <a href="#callback_ex">callback_ex</a> and <a href="#wait_for_edge">wait_for_edge</a>.
<br><br>It does not affect levels read by <a href="#gpio_read">gpio_read</a>,
<a href="#read_bank_1">read_bank_1</a>, or <a href="#read_bank_2">read_bank_2</a>.
<br><br>Level changes before and after the active period may
be reported.  Your software must be designed to cope with
such reports.
<h3><a name="read_bank_1"></a><a href="#uint32_t"><small>uint32_t</small></a> read_bank_1<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
Read the levels of the bank 1 GPIO (GPIO 0-31).
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>The returned 32 bit integer has a bit set if the corresponding
GPIO is logic 1.  GPIO n has bit value (1&lt;&lt;n).
<h3><a name="read_bank_2"></a><a href="#uint32_t"><small>uint32_t</small></a> read_bank_2<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
Read the levels of the bank 2 GPIO (GPIO 32-53).
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>The returned 32 bit integer has a bit set if the corresponding
GPIO is logic 1.  GPIO n has bit value (1&lt;&lt;(n-32)).
<h3><a name="clear_bank_1"></a><a href="#int"><small>int</small></a> clear_bank_1<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Clears GPIO 0-31 if the corresponding bit in bits is set.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;cleared.<br></code><br><br>Returns 0 if OK, otherwise PI_SOME_PERMITTED.
<br><br>A status of PI_SOME_PERMITTED indicates that the user is not
allowed to write to one or more of the GPIO.
<h3><a name="clear_bank_2"></a><a href="#int"><small>int</small></a> clear_bank_2<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Clears GPIO 32-53 if the corresponding bit (0-21) in bits is set.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;cleared.<br></code><br><br>Returns 0 if OK, otherwise PI_SOME_PERMITTED.
<br><br>A status of PI_SOME_PERMITTED indicates that the user is not
allowed to write to one or more of the GPIO.
<h3><a name="set_bank_1"></a><a href="#int"><small>int</small></a> set_bank_1<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Sets GPIO 0-31 if the corresponding bit in bits is set.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;set.<br></code><br><br>Returns 0 if OK, otherwise PI_SOME_PERMITTED.
<br><br>A status of PI_SOME_PERMITTED indicates that the user is not
allowed to write to one or more of the GPIO.
<h3><a name="set_bank_2"></a><a href="#int"><small>int</small></a> set_bank_2<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;set.<br></code><br><br>Returns 0 if OK, otherwise PI_SOME_PERMITTED.
<br><br>A status of PI_SOME_PERMITTED indicates that the user is not
allowed to write to one or more of the GPIO.
<h3><a name="hardware_clock"></a><a href="#int"><small>int</small></a> hardware_clock<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#clkfreq">clkfreq</a>)</small></h3>
Starts a hardware clock on a GPIO at the specified frequency.
Frequencies above 30MHz are unlikely to work.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpio:&nbsp;see&nbsp;description<br>frequency:&nbsp;0&nbsp;(off)&nbsp;or&nbsp;4689-250M&nbsp;(13184-375M&nbsp;for&nbsp;the&nbsp;BCM2711)<br></code><br><br>Returns 0 if OK, otherwise PI_NOT_PERMITTED, PI_BAD_GPIO,
PI_NOT_HCLK_GPIO, PI_BAD_HCLK_FREQ,or PI_BAD_HCLK_PASS.
<br><br>The same clock is available on multiple GPIO.  The latest
frequency setting will be used by all GPIO which share a clock.
<br><br>The GPIO must be one of the following.
<br><br><code>4&nbsp;&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;All&nbsp;models<br>5&nbsp;&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br>6&nbsp;&nbsp;&nbsp;clock&nbsp;2&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>20&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>21&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;Rev.2&nbsp;B&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br><br>32&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>34&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>42&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br>43&nbsp;&nbsp;clock&nbsp;2&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>44&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br></code><br><br>Access to clock 1 is protected by a password as its use will likely
crash the Pi.  The password is given by or'ing 0x5A000000 with the
GPIO number.
<h3><a name="hardware_PWM"></a><a href="#int"><small>int</small></a> hardware_PWM<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#PWMfreq">PWMfreq</a>, <a href="#uint32_t">uint32_t</a> <a href="#PWMduty">PWMduty</a>)</small></h3>
Starts hardware PWM on a GPIO at the specified frequency and dutycycle.
Frequencies above 30MHz are unlikely to work.
<br><br>NOTE: Any waveform started by <a href="#wave_send_*">wave_send_*</a> or <a href="#wave_chain">wave_chain</a>
will be cancelled.
<br><br>This function is only valid if the pigpio main clock is PCM.  The
main clock defaults to PCM but may be overridden when the pigpio
daemon is started (option -t).
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;gpio:&nbsp;see&nbsp;descripton<br>PWMfreq:&nbsp;0&nbsp;(off)&nbsp;or&nbsp;1-125M&nbsp;(1-187.5M&nbsp;for&nbsp;the&nbsp;BCM2711)<br>PWMduty:&nbsp;0&nbsp;(off)&nbsp;to&nbsp;1000000&nbsp;(1M)(fully&nbsp;on)<br></code><br><br>Returns 0 if OK, otherwise PI_NOT_PERMITTED, PI_BAD_GPIO,
PI_NOT_HPWM_GPIO, PI_BAD_HPWM_DUTY, PI_BAD_HPWM_FREQ,
or PI_HPWM_ILLEGAL.
<br><br>The same PWM channel is available on multiple GPIO.  The latest
frequency and dutycycle setting will be used by all GPIO which
share a PWM channel.
<br><br>The GPIO must be one of the following.
<br><br><code>12&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>13&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>18&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;All&nbsp;models<br>19&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br><br>40&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>41&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>45&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>52&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>53&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br></code><br><br>The actual number of steps beween off and fully on is the
integral part of 250M/PWMfreq (375M/PWMfreq for the BCM2711).
<br><br>The actual frequency set is 250M/steps (375M/steps for the BCM2711).
<br><br>There will only be a million steps for a PWMfreq of 250 (375 for
the BCM2711). Lower frequencies will have more steps and higher
frequencies will have fewer steps.  PWMduty is
automatically scaled to take this into account.
<h3><a name="get_current_tick"></a><a href="#uint32_t"><small>uint32_t</small></a> get_current_tick<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
Gets the current system tick.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>Tick is the number of microseconds since system boot.
<br><br>As tick is an unsigned 32 bit quantity it wraps around after
2**32 microseconds, which is approximately 1 hour 12 minutes.
<h3><a name="get_hardware_revision"></a><a href="#uint32_t"><small>uint32_t</small></a> get_hardware_revision<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
Get the Pi's hardware revision number.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>The hardware revision is the last few characters on the Revision line
of /proc/cpuinfo.
<br><br>If the hardware revision can not be found or is not a valid
hexadecimal number the function returns 0.
<br><br>The revision number can be used to determine the assignment of GPIO
to pins (see <a href="#gpio">gpio</a>).
<br><br>There are at least three types of board.
<br><br>Type 1 boards have hardware revision numbers of 2 and 3.
<br><br>Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.
<br><br>Type 3 boards have hardware revision numbers of 16 or greater.
<h3><a name="get_pigpio_version"></a><a href="#uint32_t"><small>uint32_t</small></a> get_pigpio_version<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
Returns the pigpio version.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_clear"></a><a href="#int"><small>int</small></a> wave_clear<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function clears all waveforms and any data added by calls to the
<a href="#wave_add_*">wave_add_*</a> functions.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>Returns 0 if OK.
<h3><a name="wave_add_new"></a><a href="#int"><small>int</small></a> wave_add_new<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function starts a new empty waveform.  You wouldn't normally need
to call this function as it is automatically called after a waveform is
created with the <a href="#wave_create">wave_create</a> function.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>Returns 0 if OK.
<h3><a name="wave_add_generic"></a><a href="#int"><small>int</small></a> wave_add_generic<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#numPulses">numPulses</a>, <a href="#gpioPulse_t">gpioPulse_t</a> <a href="#*pulses">*pulses</a>)</small></h3>
This function adds a number of pulses to the current waveform.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>numPulses:&nbsp;the&nbsp;number&nbsp;of&nbsp;pulses.<br>&nbsp;&nbsp;&nbsp;pulses:&nbsp;an&nbsp;array&nbsp;of&nbsp;pulses.<br></code><br><br>Returns the new total number of pulses in the current waveform if OK,
otherwise PI_TOO_MANY_PULSES.
<br><br>The pulses are interleaved in time order within the existing waveform
(if any).
<br><br>Merging allows the waveform to be built in parts, that is the settings
for GPIO#1 can be added, and then GPIO#2 etc.
<br><br>If the added waveform is intended to start after or within the existing
waveform then the first pulse should consist solely of a delay.
<h3><a name="wave_add_serial"></a><a href="#int"><small>int</small></a> wave_add_serial<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#data_bits">data_bits</a>, <a href="#unsigned">unsigned</a> <a href="#stop_bits">stop_bits</a>, <a href="#unsigned">unsigned</a> <a href="#offset">offset</a>, <a href="#unsigned">unsigned</a> <a href="#numBytes">numBytes</a>, <a href="#char">char</a> <a href="#*str">*str</a>)</small></h3>
This function adds a waveform representing serial data to the
existing waveform (if any).  The serial data starts offset
microseconds from the start of the waveform.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;50-1000000<br>data_bits:&nbsp;number&nbsp;of&nbsp;data&nbsp;bits&nbsp;(1-32)<br>stop_bits:&nbsp;number&nbsp;of&nbsp;stop&nbsp;half&nbsp;bits&nbsp;(2-8)<br>&nbsp;&nbsp;&nbsp;offset:&nbsp;&gt;=0<br>&nbsp;numBytes:&nbsp;&gt;=1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str:&nbsp;an&nbsp;array&nbsp;of&nbsp;chars.<br></code><br><br>Returns the new total number of pulses in the current waveform if OK,
otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD, PI_BAD_DATABITS,
PI_BAD_STOP_BITS, PI_TOO_MANY_CHARS, PI_BAD_SER_OFFSET,
or PI_TOO_MANY_PULSES.
<br><br>NOTES:
<br><br>The serial data is formatted as one start bit, <a href="#data_bits">data_bits</a> data bits,
and <a href="#stop_bits">stop_bits</a>/2 stop bits.
<br><br>It is legal to add serial data streams with different baud rates to
the same waveform.
<br><br><a href="#numBytes">numBytes</a> is the number of bytes of data in str.
<br><br>The bytes required for each character depend upon <a href="#data_bits">data_bits</a>.
<br><br>For <a href="#data_bits">data_bits</a> 1-8 there will be one byte per character.<br>
For <a href="#data_bits">data_bits</a> 9-16 there will be two bytes per character.<br>
For <a href="#data_bits">data_bits</a> 17-32 there will be four bytes per character.
<h3><a name="wave_create"></a><a href="#int"><small>int</small></a> wave_create<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function creates a waveform from the data provided by the prior
calls to the <a href="#wave_add_*">wave_add_*</a> functions.  Upon success a wave id
greater than or equal to 0 is returned, otherwise PI_EMPTY_WAVEFORM,
PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>The data provided by the <a href="#wave_add_*">wave_add_*</a> functions is consumed by this
function.
<br><br>As many waveforms may be created as there is space available.  The
wave id is passed to <a href="#wave_send_*">wave_send_*</a> to specify the waveform to transmit.
<br><br>Normal usage would be
<br><br>Step 1. <a href="#wave_clear">wave_clear</a> to clear all waveforms and added data.
<br><br>Step 2. <a href="#wave_add_*">wave_add_*</a> calls to supply the waveform data.
<br><br>Step 3. <a href="#wave_create">wave_create</a> to create the waveform and get a unique id
<br><br>Repeat steps 2 and 3 as needed.
<br><br>Step 4. <a href="#wave_send_*">wave_send_*</a> with the id of the waveform to transmit.
<br><br>A waveform comprises one or more pulses.  Each pulse consists of a
<a href="#gpioPulse_t">gpioPulse_t</a> structure.
<br><br><code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOn;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOff;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;usDelay;<br>}&nbsp;gpioPulse_t;<br></code><br><br>The fields specify
<br><br>1) the GPIO to be switched on at the start of the pulse.<br>
2) the GPIO to be switched off at the start of the pulse.<br>
3) the delay in microseconds before the next pulse.<br>
<br><br>Any or all the fields can be zero.  It doesn't make any sense to
set all the fields to zero (the pulse will be ignored).
<br><br>When a waveform is started each pulse is executed in order with the
specified delay between the pulse and the next.
<br><br>Returns the new waveform id if OK, otherwise PI_EMPTY_WAVEFORM,
PI_NO_WAVEFORM_ID, PI_TOO_MANY_CBS, or PI_TOO_MANY_OOL.
<h3><a name="wave_create_and_pad"></a><a href="#int"><small>int</small></a> wave_create_and_pad<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#int">int</a> <a href="#percent">percent</a>)</small></h3>
This function creates a waveform like <a href="#wave_create">wave_create</a> but pads the consumed
resources. Where percent gives the percentage of the resources to use (in terms
of the theoretical maximum, not the current amount free). This allows the reuse<br>
of deleted waves while a transmission is active.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>percent:&nbsp;0-100,&nbsp;size&nbsp;of&nbsp;waveform&nbsp;as&nbsp;percentage&nbsp;of&nbsp;maximum&nbsp;available.<br></code><br><br>The data provided by the <a href="#wave_add_*">wave_add_*</a> functions are consumed by this
function.
<br><br>As many waveforms may be created as there is space available. The
wave id is passed to <a href="#wave_send_*">wave_send_*</a> to specify the waveform to transmit.
<br><br>A usage would be the creation of two waves where one is filled while the other
is being transmitted. Each wave is assigned 50% of the resources.
This buffer structure allows the transmission of infinite wave sequences.
<br><br>Normal usage:
<br><br>Step 1. <a href="#wave_clear">wave_clear</a> to clear all waveforms and added data.
<br><br>Step 2. <a href="#wave_add_*">wave_add_*</a> calls to supply the waveform data.
<br><br>Step 3. <a href="#wave_create_and_pad">wave_create_and_pad</a> to create a waveform of uniform size.
<br><br>Step 4. <a href="#wave_send_*">wave_send_*</a> with the id of the waveform to transmit.
<br><br>Repeat steps 2-4 as needed.
<br><br>Step 5. Any wave id can now be deleted and another wave of the same size
        can be created in its place.
<br><br>Returns the new waveform id if OK, otherwise PI_EMPTY_WAVEFORM,
PI_NO_WAVEFORM_ID, PI_TOO_MANY_CBS, or PI_TOO_MANY_OOL.
<h3><a name="wave_delete"></a><a href="#int"><small>int</small></a> wave_delete<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#wave_id">wave_id</a>)</small></h3>
This function deletes the waveform with id wave_id.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>wave_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#wave_create">wave_create</a>.<br></code><br><br>Wave ids are allocated in order, 0, 1, 2, etc.
<br><br>The wave is flagged for deletion.  The resources used by the wave
will only be reused when either of the following apply.
<br><br>- all waves with higher numbered wave ids have been deleted or have
been flagged for deletion.
<br><br>- a new wave is created which uses exactly the same resources as
the current wave (see the C source for gpioWaveCreate for details).
<br><br>Returns 0 if OK, otherwise PI_BAD_WAVE_ID.
<h3><a name="wave_send_once"></a><a href="#int"><small>int</small></a> wave_send_once<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#wave_id">wave_id</a>)</small></h3>
This function transmits the waveform with id wave_id.  The waveform
is sent once.
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a> will be cancelled.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>wave_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#wave_create">wave_create</a>.<br></code><br><br>Returns the number of DMA control blocks in the waveform if OK,
otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.
<h3><a name="wave_send_repeat"></a><a href="#int"><small>int</small></a> wave_send_repeat<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#wave_id">wave_id</a>)</small></h3>
This function transmits the waveform with id wave_id.  The waveform
cycles until cancelled (either by the sending of a new waveform or
by <a href="#wave_tx_stop">wave_tx_stop</a>).
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a> will be cancelled.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>wave_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#wave_create">wave_create</a>.<br></code><br><br>Returns the number of DMA control blocks in the waveform if OK,
otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.
<h3><a name="wave_send_using_mode"></a><a href="#int"><small>int</small></a> wave_send_using_mode<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#wave_id">wave_id</a>, <a href="#unsigned">unsigned</a> <a href="#mode">mode</a>)</small></h3>
Transmits the waveform with id wave_id using mode mode.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>wave_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#wave_create">wave_create</a>.<br>&nbsp;&nbsp;&nbsp;mode:&nbsp;PI_WAVE_MODE_ONE_SHOT,&nbsp;PI_WAVE_MODE_REPEAT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PI_WAVE_MODE_ONE_SHOT_SYNC,&nbsp;or&nbsp;PI_WAVE_MODE_REPEAT_SYNC.<br></code><br><br>PI_WAVE_MODE_ONE_SHOT: same as <a href="#wave_send_once">wave_send_once</a>.
<br><br>PI_WAVE_MODE_REPEAT same as <a href="#wave_send_repeat">wave_send_repeat</a>.
<br><br>PI_WAVE_MODE_ONE_SHOT_SYNC same as <a href="#wave_send_once">wave_send_once</a> but tries
to sync with the previous waveform.
<br><br>PI_WAVE_MODE_REPEAT_SYNC same as <a href="#wave_send_repeat">wave_send_repeat</a> but tries
to sync with the previous waveform.
<br><br>WARNING: bad things may happen if you delete the previous
waveform before it has been synced to the new waveform.
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a> will be cancelled.
<br><br>Returns the number of DMA control blocks in the waveform if OK,
otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.
<h3><a name="wave_chain"></a><a href="#int"><small>int</small></a> wave_chain<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#bufSize">bufSize</a>)</small></h3>
This function transmits a chain of waveforms.
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a> will be cancelled.
<br><br>The waves to be transmitted are specified by the contents of buf
which contains an ordered list of <a href="#wave_id">wave_id</a>s and optional command
codes and related data.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;pointer&nbsp;to&nbsp;the&nbsp;wave_ids&nbsp;and&nbsp;optional&nbsp;command&nbsp;codes<br>bufSize:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;in&nbsp;buf<br></code><br><br>Returns 0 if OK, otherwise PI_CHAIN_NESTING, PI_CHAIN_LOOP_CNT, PI_BAD_CHAIN_LOOP, PI_BAD_CHAIN_CMD, PI_CHAIN_COUNTER,
PI_BAD_CHAIN_DELAY, PI_CHAIN_TOO_BIG, or PI_BAD_WAVE_ID.
<br><br>Each wave is transmitted in the order specified.  A wave may
occur multiple times per chain.
<br><br>A blocks of waves may be transmitted multiple times by using
the loop commands. The block is bracketed by loop start and
end commands.  Loops may be nested.
<br><br>Delays between waves may be added with the delay command.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>Loop Start</td><td>255 0</td><td>Identify start of a wave block</td></tr><tr><td>Loop Repeat</td><td>255 1 x y</td><td>loop x + y*256 times</td></tr><tr><td>Delay</td><td>255 2 x y</td><td>delay x + y*256 microseconds</td></tr><tr><td>Loop Forever</td><td>255 3</td><td>loop forever</td></tr></tbody></table><br><br>If present Loop Forever must be the last entry in the chain.
<br><br>The code is currently dimensioned to support a chain with roughly
600 entries and 20 loop counters.
<br><br><b><small>Example</small></b><br><br><code>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;pigpiod_if2.h&gt;<br><br>#define&nbsp;WAVES&nbsp;5<br>#define&nbsp;GPIO&nbsp;4<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;pi,&nbsp;wid[WAVES];<br><br>&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;pigpio_start(0,&nbsp;0);<br>&nbsp;&nbsp;&nbsp;if&nbsp;(pi&lt;0)&nbsp;return&nbsp;-1;<br><br>&nbsp;&nbsp;&nbsp;set_mode(pi,&nbsp;GPIO,&nbsp;PI_OUTPUT);<br><br>&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;WAVES;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wave_add_generic(pi,&nbsp;2,&nbsp;(gpioPulse_t[])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{1&lt;&lt;GPIO,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0,&nbsp;1&lt;&lt;GPIO,&nbsp;(i+1)*200}});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[i]&nbsp;=&nbsp;wave_create(pi);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;wave_chain(pi,&nbsp;(char&nbsp;[])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[4],&nbsp;wid[3],&nbsp;wid[2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;4+3+2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[0],&nbsp;wid[0],&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;0+1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;2,&nbsp;0x88,&nbsp;0x13,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;delay&nbsp;5000us<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;30,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;30&nbsp;times)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[2],&nbsp;wid[3],&nbsp;wid[0],&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;2+3+0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[3],&nbsp;wid[1],&nbsp;wid[2],&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;3+1+2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;10,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;10&nbsp;times)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;5,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;5&nbsp;times)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[4],&nbsp;wid[4],&nbsp;wid[4],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;4+4+4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;2,&nbsp;0x20,&nbsp;0x4E,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;delay&nbsp;20000us<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[0],&nbsp;wid[0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;46);<br><br>&nbsp;&nbsp;&nbsp;while&nbsp;(wave_tx_busy(pi))&nbsp;time_sleep(0.1);<br><br>&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;WAVES;&nbsp;i++)&nbsp;wave_delete(pi,&nbsp;wid[i]);<br><br>&nbsp;&nbsp;&nbsp;pigpio_stop(pi);<br>}<br></code><h3><a name="wave_tx_at"></a><a href="#int"><small>int</small></a> wave_tx_at<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the id of the waveform currently being
transmitted.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>Returns the waveform id or one of the following special values:
<br><br>PI_WAVE_NOT_FOUND (9998) - transmitted wave not found.<br>
PI_NO_TX_WAVE (9999) - no wave being transmitted.
<h3><a name="wave_tx_busy"></a><a href="#int"><small>int</small></a> wave_tx_busy<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function checks to see if a waveform is currently being
transmitted.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>Returns 1 if a waveform is currently being transmitted, otherwise 0.
<h3><a name="wave_tx_stop"></a><a href="#int"><small>int</small></a> wave_tx_stop<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function stops the transmission of the current waveform.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>Returns 0 if OK.
<br><br>This function is intended to stop a waveform started with the repeat mode.
<h3><a name="wave_get_micros"></a><a href="#int"><small>int</small></a> wave_get_micros<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the length in microseconds of the current
waveform.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_high_micros"></a><a href="#int"><small>int</small></a> wave_get_high_micros<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the length in microseconds of the longest waveform
created since the pigpio daemon was started.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_max_micros"></a><a href="#int"><small>int</small></a> wave_get_max_micros<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the maximum possible size of a waveform in<br>
microseconds.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_pulses"></a><a href="#int"><small>int</small></a> wave_get_pulses<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the length in pulses of the current waveform.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_high_pulses"></a><a href="#int"><small>int</small></a> wave_get_high_pulses<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the length in pulses of the longest waveform
created since the pigpio daemon was started.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_max_pulses"></a><a href="#int"><small>int</small></a> wave_get_max_pulses<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the maximum possible size of a waveform in pulses.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_cbs"></a><a href="#int"><small>int</small></a> wave_get_cbs<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the length in DMA control blocks of the current
waveform.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_high_cbs"></a><a href="#int"><small>int</small></a> wave_get_high_cbs<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the length in DMA control blocks of the longest
waveform created since the pigpio daemon was started.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="wave_get_max_cbs"></a><a href="#int"><small>int</small></a> wave_get_max_cbs<small>(<a href="#int">int</a> <a href="#pi">pi</a>)</small></h3>
This function returns the maximum possible size of a waveform in DMA
control blocks.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><h3><a name="gpio_trigger"></a><a href="#int"><small>int</small></a> gpio_trigger<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#pulseLen">pulseLen</a>, <a href="#unsigned">unsigned</a> <a href="#level">level</a>)</small></h3>
This function sends a trigger pulse to a GPIO.  The GPIO is set to
level for pulseLen microseconds and then reset to not level.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;pulseLen:&nbsp;1-100.<br>&nbsp;&nbsp;&nbsp;&nbsp;level:&nbsp;0,1.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_LEVEL,
PI_BAD_PULSELEN, or PI_NOT_PERMITTED.
<h3><a name="store_script"></a><a href="#int"><small>int</small></a> store_script<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#char">char</a> <a href="#*script">*script</a>)</small></h3>
This function stores a script for later execution.
<br><br>See <a href="http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts">http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts</a> for details.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>script:&nbsp;the&nbsp;text&nbsp;of&nbsp;the&nbsp;script.<br></code><br><br>The function returns a script id if the script is valid,
otherwise PI_BAD_SCRIPT.
<h3><a name="run_script"></a><a href="#int"><small>int</small></a> run_script<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>, <a href="#unsigned">unsigned</a> <a href="#numPar">numPar</a>, <a href="#uint32_t">uint32_t</a> <a href="#*param">*param</a>)</small></h3>
This function runs a stored script.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#store_script">store_script</a>.<br>&nbsp;&nbsp;&nbsp;numPar:&nbsp;0-10,&nbsp;the&nbsp;number&nbsp;of&nbsp;parameters.<br>&nbsp;&nbsp;&nbsp;&nbsp;param:&nbsp;an&nbsp;array&nbsp;of&nbsp;parameters.<br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM
<br><br>param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.
<h3><a name="update_script"></a><a href="#int"><small>int</small></a> update_script<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>, <a href="#unsigned">unsigned</a> <a href="#numPar">numPar</a>, <a href="#uint32_t">uint32_t</a> <a href="#*param">*param</a>)</small></h3>
This function sets the parameters of a script.  The script may or
may not be running.  The first numPar parameters of the script are
overwritten with the new values.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#store_script">store_script</a>.<br>&nbsp;&nbsp;&nbsp;numPar:&nbsp;0-10,&nbsp;the&nbsp;number&nbsp;of&nbsp;parameters.<br>&nbsp;&nbsp;&nbsp;&nbsp;param:&nbsp;an&nbsp;array&nbsp;of&nbsp;parameters.<br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM.
<br><br>param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.
<h3><a name="script_status"></a><a href="#int"><small>int</small></a> script_status<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>, <a href="#uint32_t">uint32_t</a> <a href="#*param">*param</a>)</small></h3>
This function returns the run status of a stored script as well
as the current values of parameters 0 to 9.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#store_script">store_script</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;param:&nbsp;an&nbsp;array&nbsp;to&nbsp;hold&nbsp;the&nbsp;returned&nbsp;10&nbsp;parameters.<br></code><br><br>The function returns greater than or equal to 0 if OK,
otherwise PI_BAD_SCRIPT_ID.
<br><br>The run status may be
<br><br><code>PI_SCRIPT_INITING<br>PI_SCRIPT_HALTED<br>PI_SCRIPT_RUNNING<br>PI_SCRIPT_WAITING<br>PI_SCRIPT_FAILED<br></code><br><br>The current value of script parameters 0 to 9 are returned in param.
<h3><a name="stop_script"></a><a href="#int"><small>int</small></a> stop_script<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>)</small></h3>
This function stops a running script.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#store_script">store_script</a>.<br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.
<h3><a name="delete_script"></a><a href="#int"><small>int</small></a> delete_script<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>)</small></h3>
This function deletes a stored script.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#store_script">store_script</a>.<br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.
<h3><a name="bb_serial_read_open"></a><a href="#int"><small>int</small></a> bb_serial_read_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#data_bits">data_bits</a>)</small></h3>
This function opens a GPIO for bit bang reading of serial data.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;50-250000<br>data_bits:&nbsp;1-32<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD,
or PI_GPIO_IN_USE.
<br><br>The serial data is returned in a cyclic buffer and is read using
bb_serial_read.
<br><br>It is the caller's responsibility to read data from the cyclic buffer
in a timely fashion.
<h3><a name="bb_serial_read"></a><a href="#int"><small>int</small></a> bb_serial_read<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#void">void</a> <a href="#*buf">*buf</a>, <a href="#size_t">size_t</a> <a href="#bufSize">bufSize</a>)</small></h3>
This function copies up to bufSize bytes of data read from the
bit bang serial cyclic buffer to the buffer starting at buf.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31,&nbsp;previously&nbsp;opened&nbsp;with&nbsp;<a href="#bb_serial_read_open">bb_serial_read_open</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;bytes.<br>&nbsp;&nbsp;bufSize:&nbsp;&gt;=0<br></code><br><br>Returns the number of bytes copied if OK, otherwise PI_BAD_USER_GPIO
or PI_NOT_SERIAL_GPIO.
<br><br>The bytes returned for each character depend upon the number of
data bits <a href="#data_bits">data_bits</a> specified in the <a href="#bb_serial_read_open">bb_serial_read_open</a> command.
<br><br>For <a href="#data_bits">data_bits</a> 1-8 there will be one byte per character.<br>
For <a href="#data_bits">data_bits</a> 9-16 there will be two bytes per character.<br>
For <a href="#data_bits">data_bits</a> 17-32 there will be four bytes per character.
<h3><a name="bb_serial_read_close"></a><a href="#int"><small>int</small></a> bb_serial_read_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
This function closes a GPIO for bit bang reading of serial data.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31,&nbsp;previously&nbsp;opened&nbsp;with&nbsp;<a href="#bb_serial_read_open">bb_serial_read_open</a>.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SERIAL_GPIO.
<h3><a name="bb_serial_invert"></a><a href="#int"><small>int</small></a> bb_serial_invert<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#invert">invert</a>)</small></h3>
This function inverts serial logic for big bang serial reads.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31,&nbsp;previously&nbsp;opened&nbsp;with&nbsp;<a href="#bb_serial_read_open">bb_serial_read_open</a>.<br>&nbsp;&nbsp;&nbsp;invert:&nbsp;0-1,&nbsp;1&nbsp;invert,&nbsp;0&nbsp;normal.<br></code><br><br>Returns 0 if OK, otherwise PI_NOT_SERIAL_GPIO or PI_BAD_SER_INVERT.
<h3><a name="i2c_open"></a><a href="#int"><small>int</small></a> i2c_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_bus">i2c_bus</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_addr">i2c_addr</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_flags">i2c_flags</a>)</small></h3>
This returns a handle for the device at address i2c_addr on bus i2c_bus.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;i2c_bus:&nbsp;&gt;=0.<br>&nbsp;i2c_addr:&nbsp;0-0x7F.<br>i2c_flags:&nbsp;0.<br></code><br><br>No flags are currently defined.  This parameter should be set to zero.
<br><br>Physically buses 0 and 1 are available on the Pi.  Higher numbered buses
will be available if a kernel supported bus multiplexor is being used.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td></tr><tr><td>I2C 0</td><td>0</td><td>1</td></tr><tr><td>I2C 1</td><td>2</td><td>3</td></tr></tbody></table><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_BAD_I2C_BUS, PI_BAD_I2C_ADDR,
PI_BAD_FLAGS, PI_NO_HANDLE, or PI_I2C_OPEN_FAILED.
<br><br>For the SMBus commands the low level transactions are shown at the end
of the function description.  The following abbreviations are used.
<br><br><code>S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Start&nbsp;bit<br>P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Stop&nbsp;bit<br>Rd/Wr&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Read/Write&nbsp;bit.&nbsp;Rd&nbsp;equals&nbsp;1,&nbsp;Wr&nbsp;equals&nbsp;0.<br>A,&nbsp;NA&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Accept&nbsp;and&nbsp;not&nbsp;accept&nbsp;bit.<br><br>Addr&nbsp;&nbsp;&nbsp;&nbsp;(7&nbsp;bits):&nbsp;I2C&nbsp;7&nbsp;bit&nbsp;address.<br>i2c_reg&nbsp;(8&nbsp;bits):&nbsp;A&nbsp;byte&nbsp;which&nbsp;often&nbsp;selects&nbsp;a&nbsp;register.<br>Data&nbsp;&nbsp;&nbsp;&nbsp;(8&nbsp;bits):&nbsp;A&nbsp;data&nbsp;byte.<br>Count&nbsp;&nbsp;&nbsp;(8&nbsp;bits):&nbsp;A&nbsp;byte&nbsp;defining&nbsp;the&nbsp;length&nbsp;of&nbsp;a&nbsp;block&nbsp;operation.<br><br>[..]:&nbsp;Data&nbsp;sent&nbsp;by&nbsp;the&nbsp;device.<br></code><h3><a name="i2c_close"></a><a href="#int"><small>int</small></a> i2c_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This closes the I2C device associated with the handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<h3><a name="i2c_write_quick"></a><a href="#int"><small>int</small></a> i2c_write_quick<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#bit">bit</a>)</small></h3>
This sends a single bit (in the Rd/Wr bit) to the device associated
with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>&nbsp;&nbsp;&nbsp;bit:&nbsp;0-1,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Quick command. SMBus 2.0 5.5.1
<code>S&nbsp;Addr&nbsp;bit&nbsp;[A]&nbsp;P<br></code><h3><a name="i2c_write_byte"></a><a href="#int"><small>int</small></a> i2c_write_byte<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#bVal">bVal</a>)</small></h3>
This sends a single byte to the device associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>&nbsp;&nbsp;bVal:&nbsp;0-0xFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Send byte. SMBus 2.0 5.5.2
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;bVal&nbsp;[A]&nbsp;P<br></code><h3><a name="i2c_read_byte"></a><a href="#int"><small>int</small></a> i2c_read_byte<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This reads a single byte from the device associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br></code><br><br>Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
or PI_I2C_READ_FAILED.
<br><br>Receive byte. SMBus 2.0 5.5.3
<code>S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><h3><a name="i2c_write_byte_data"></a><a href="#int"><small>int</small></a> i2c_write_byte_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#unsigned">unsigned</a> <a href="#bVal">bVal</a>)</small></h3>
This writes a single byte to the specified register of the device
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write.<br>&nbsp;&nbsp;&nbsp;bVal:&nbsp;0-0xFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Write byte. SMBus 2.0 5.5.4
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]&nbsp;bVal&nbsp;[A]&nbsp;P<br></code><h3><a name="i2c_write_word_data"></a><a href="#int"><small>int</small></a> i2c_write_word_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#unsigned">unsigned</a> <a href="#wVal">wVal</a>)</small></h3>
This writes a single 16 bit word to the specified register of the device
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write.<br>&nbsp;&nbsp;&nbsp;wVal:&nbsp;0-0xFFFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Write word. SMBus 2.0 5.5.4
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]&nbsp;wval_Low&nbsp;[A]&nbsp;wVal_High&nbsp;[A]&nbsp;P<br></code><h3><a name="i2c_read_byte_data"></a><a href="#int"><small>int</small></a> i2c_read_byte_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>)</small></h3>
This reads a single byte from the specified register of the device
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read.<br></code><br><br>Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Read byte. SMBus 2.0 5.5.5
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><h3><a name="i2c_read_word_data"></a><a href="#int"><small>int</small></a> i2c_read_word_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>)</small></h3>
This reads a single 16 bit word from the specified register of the device
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read.<br></code><br><br>Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Read word. SMBus 2.0 5.5.5
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[DataLow]&nbsp;A&nbsp;[DataHigh]&nbsp;NA&nbsp;P<br></code><h3><a name="i2c_process_call"></a><a href="#int"><small>int</small></a> i2c_process_call<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#unsigned">unsigned</a> <a href="#wVal">wVal</a>)</small></h3>
This writes 16 bits of data to the specified register of the device
associated with handle and and reads 16 bits of data in return.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write/read.<br>&nbsp;&nbsp;&nbsp;wVal:&nbsp;0-0xFFFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></code><br><br>Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Process call. SMBus 2.0 5.5.6
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]&nbsp;wVal_Low&nbsp;[A]&nbsp;wVal_High&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[DataLow]&nbsp;A&nbsp;[DataHigh]&nbsp;NA&nbsp;P<br></code><h3><a name="i2c_write_block_data"></a><a href="#int"><small>int</small></a> i2c_write_block_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes up to 32 bytes to the specified register of the device
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write.<br>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;with&nbsp;the&nbsp;data&nbsp;to&nbsp;send.<br>&nbsp;&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Block write. SMBus 2.0 5.5.7
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]&nbsp;count&nbsp;[A]&nbsp;buf0&nbsp;[A]&nbsp;buf1&nbsp;[A]&nbsp;...<br>&nbsp;&nbsp;&nbsp;[A]&nbsp;bufn&nbsp;[A]&nbsp;P<br></code><h3><a name="i2c_read_block_data"></a><a href="#int"><small>int</small></a> i2c_read_block_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>)</small></h3>
This reads a block of up to 32 bytes from the specified register of
the device associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read.<br>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data.<br></code><br><br>The amount of returned data is set by the device.
<br><br>Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Block read. SMBus 2.0 5.5.7
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Count]&nbsp;A&nbsp;[buf0]&nbsp;A&nbsp;[buf1]&nbsp;A&nbsp;...&nbsp;A&nbsp;[bufn]&nbsp;NA&nbsp;P<br></code><h3><a name="i2c_block_process_call"></a><a href="#int"><small>int</small></a> i2c_block_process_call<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes data bytes to the specified register of the device
associated with handle and reads a device specified number
of bytes of data in return.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write/read.<br>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;with&nbsp;the&nbsp;data&nbsp;to&nbsp;send&nbsp;and&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data.<br>&nbsp;&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br></code><br><br>Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>The smbus 2.0 documentation states that a minimum of 1 byte may be
sent and a minimum of 1 byte may be received.  The total number of
bytes sent/received must be 32 or less.
<br><br>Block write-block read. SMBus 2.0 5.5.8
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]&nbsp;count&nbsp;[A]&nbsp;buf0&nbsp;[A]&nbsp;...<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Count]&nbsp;A&nbsp;[Data]&nbsp;...&nbsp;A&nbsp;P<br></code><h3><a name="i2c_read_i2c_block_data"></a><a href="#int"><small>int</small></a> i2c_read_i2c_block_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This reads count bytes from the specified register of the device
associated with handle .  The count may be 1-32.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read.<br>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data.<br>&nbsp;&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></code><br><br>Returns the number of bytes read (&gt;0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[buf0]&nbsp;A&nbsp;[buf1]&nbsp;A&nbsp;...&nbsp;A&nbsp;[bufn]&nbsp;NA&nbsp;P<br></code><h3><a name="i2c_write_i2c_block_data"></a><a href="#int"><small>int</small></a> i2c_write_i2c_block_data<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2c_reg">i2c_reg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes 1 to 32 bytes to the specified register of the device
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>i2c_reg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write.<br>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;data&nbsp;to&nbsp;write.<br>&nbsp;&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2c_reg&nbsp;[A]&nbsp;buf0&nbsp;[A]&nbsp;buf1&nbsp;[A]&nbsp;...&nbsp;[A]&nbsp;bufn&nbsp;[A]&nbsp;P<br></code><h3><a name="i2c_read_device"></a><a href="#int"><small>int</small></a> i2c_read_device<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This reads count bytes from the raw device into buf.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data&nbsp;bytes.<br>&nbsp;count:&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></code><br><br>Returns count (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_READ_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[buf0]&nbsp;A&nbsp;[buf1]&nbsp;A&nbsp;...&nbsp;A&nbsp;[bufn]&nbsp;NA&nbsp;P<br></code><h3><a name="i2c_write_device"></a><a href="#int"><small>int</small></a> i2c_write_device<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes count bytes from buf to the raw device.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>.<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;containing&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;write.<br>&nbsp;count:&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;buf0&nbsp;[A]&nbsp;buf1&nbsp;[A]&nbsp;...&nbsp;[A]&nbsp;bufn&nbsp;[A]&nbsp;P<br></code><h3><a name="i2c_zip"></a><a href="#int"><small>int</small></a> i2c_zip<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*inBuf">*inBuf</a>, <a href="#unsigned">unsigned</a> <a href="#inLen">inLen</a>, <a href="#char">char</a> <a href="#*outBuf">*outBuf</a>, <a href="#unsigned">unsigned</a> <a href="#outLen">outLen</a>)</small></h3>
This function executes a sequence of I2C operations.  The
operations to be performed are specified by the contents of inBuf
which contains the concatenated command codes and associated data.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>&nbsp;inBuf:&nbsp;pointer&nbsp;to&nbsp;the&nbsp;concatenated&nbsp;I2C&nbsp;commands,&nbsp;see&nbsp;below<br>&nbsp;inLen:&nbsp;size&nbsp;of&nbsp;command&nbsp;buffer<br>outBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;returned&nbsp;data<br>outLen:&nbsp;size&nbsp;of&nbsp;output&nbsp;buffer<br></code><br><br>Returns &gt;= 0 if OK (the number of bytes read), otherwise
PI_BAD_HANDLE, PI_BAD_POINTER, PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN.
PI_BAD_I2C_WLEN, or PI_BAD_I2C_SEG.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>On</td><td>2</td><td>Switch combined flag on</td></tr><tr><td>Off</td><td>3</td><td>Switch combined flag off</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address defaults to that associated with the handle.
The flags default to 0.  The address and flags maintain their
previous value until updated.
<br><br>The returned I2C data is stored in consecutive locations of outBuf.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53,&nbsp;write&nbsp;0x32,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x1E,&nbsp;write&nbsp;0x03,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x68,&nbsp;write&nbsp;0x1B,&nbsp;read&nbsp;8&nbsp;bytes<br>End<br><br>0x04&nbsp;0x53&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x1E&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x68&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x06&nbsp;0x08<br>0x00<br></code><h3><a name="bb_i2c_open"></a><a href="#int"><small>int</small></a> bb_i2c_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#SDA">SDA</a>, <a href="#unsigned">unsigned</a> <a href="#SCL">SCL</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>)</small></h3>
This function selects a pair of GPIO for bit banging I2C at a
specified baud rate.
<br><br>Bit banging I2C allows for certain operations which are not possible
with the standard I2C driver.
<br><br>o baud rates as low as 50<br>
o repeated starts<br>
o clock stretching<br>
o I2C on any pair of spare GPIO
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;SDA:&nbsp;0-31<br>&nbsp;SCL:&nbsp;0-31<br>baud:&nbsp;50-500000<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_I2C_BAUD, or
PI_GPIO_IN_USE.
<br><br>NOTE:
<br><br>The GPIO used for SDA and SCL must have pull-ups to 3V3 connected.  As
a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.
<h3><a name="bb_i2c_close"></a><a href="#int"><small>int</small></a> bb_i2c_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#SDA">SDA</a>)</small></h3>
This function stops bit banging I2C on a pair of GPIO previously
opened with <a href="#bb_i2c_open">bb_i2c_open</a>.
<br><br><code>&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>SDA:&nbsp;0-31,&nbsp;the&nbsp;SDA&nbsp;GPIO&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_i2c_open">bb_i2c_open</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_I2C_GPIO.
<h3><a name="bb_i2c_zip"></a><a href="#int"><small>int</small></a> bb_i2c_zip<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#SDA">SDA</a>, <a href="#char">char</a> <a href="#*inBuf">*inBuf</a>, <a href="#unsigned">unsigned</a> <a href="#inLen">inLen</a>, <a href="#char">char</a> <a href="#*outBuf">*outBuf</a>, <a href="#unsigned">unsigned</a> <a href="#outLen">outLen</a>)</small></h3>
This function executes a sequence of bit banged I2C operations.  The
operations to be performed are specified by the contents of inBuf
which contains the concatenated command codes and associated data.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;SDA:&nbsp;0-31&nbsp;(as&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_i2c_open">bb_i2c_open</a>)<br>&nbsp;inBuf:&nbsp;pointer&nbsp;to&nbsp;the&nbsp;concatenated&nbsp;I2C&nbsp;commands,&nbsp;see&nbsp;below<br>&nbsp;inLen:&nbsp;size&nbsp;of&nbsp;command&nbsp;buffer<br>outBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;returned&nbsp;data<br>outLen:&nbsp;size&nbsp;of&nbsp;output&nbsp;buffer<br></code><br><br>Returns &gt;= 0 if OK (the number of bytes read), otherwise
PI_BAD_USER_GPIO, PI_NOT_I2C_GPIO, PI_BAD_POINTER,
PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN, PI_BAD_I2C_WLEN,
PI_I2C_READ_FAILED, or PI_I2C_WRITE_FAILED.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>Start</td><td>2</td><td>Start condition</td></tr><tr><td>Stop</td><td>3</td><td>Stop condition</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address and flags default to 0.  The address and flags maintain
their previous value until updated.
<br><br>No flags are currently defined.
<br><br>The returned I2C data is stored in consecutive locations of outBuf.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53<br>start,&nbsp;write&nbsp;0x32,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x1E<br>start,&nbsp;write&nbsp;0x03,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x68<br>start,&nbsp;write&nbsp;0x1B,&nbsp;(re)start,&nbsp;read&nbsp;8&nbsp;bytes,&nbsp;stop<br>End<br><br>0x04&nbsp;0x53<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x1E<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x68<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x08&nbsp;0x03<br><br>0x00<br></code><h3><a name="bb_spi_open"></a><a href="#int"><small>int</small></a> bb_spi_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#CS">CS</a>, <a href="#unsigned">unsigned</a> <a href="#MISO">MISO</a>, <a href="#unsigned">unsigned</a> <a href="#MOSI">MOSI</a>, <a href="#unsigned">unsigned</a> <a href="#SCLK">SCLK</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#spi_flags">spi_flags</a>)</small></h3>
This function selects a set of GPIO for bit banging SPI at a
specified baud rate.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CS:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MISO:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOSI:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCLK:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;50-250000<br>spi_flags:&nbsp;see&nbsp;below<br></code><br><br>spi_flags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;p&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode, defaults to 0
<br><br><code>Mode&nbsp;CPOL&nbsp;CPHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1<br></code><br><br>p is 0 if CS is active low (default) and 1 for active high.
<br><br>T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.
<br><br>R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.
<br><br>The other bits in flags should be set to zero.
<br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_SPI_BAUD, or
PI_GPIO_IN_USE.
<br><br>If more than one device is connected to the SPI bus (defined by
SCLK, MOSI, and MISO) each must have its own CS.
<br><br><b><small>Example</small></b><br><br><code>bb_spi_open(pi,10,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;10000,&nbsp;0);&nbsp;//&nbsp;device&nbsp;1<br>bb_spi_open(pi,11,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;20000,&nbsp;3);&nbsp;//&nbsp;device&nbsp;2<br></code><h3><a name="bb_spi_close"></a><a href="#int"><small>int</small></a> bb_spi_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#CS">CS</a>)</small></h3>
This function stops bit banging SPI on a set of GPIO
opened with <a href="#bbSPIOpen">bbSPIOpen</a>.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>CS:&nbsp;0-31,&nbsp;the&nbsp;CS&nbsp;GPIO&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_spi_open">bb_spi_open</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SPI_GPIO.
<h3><a name="bb_spi_xfer"></a><a href="#int"><small>int</small></a> bb_spi_xfer<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#CS">CS</a>, <a href="#char">char</a> <a href="#*txBuf">*txBuf</a>, <a href="#char">char</a> <a href="#*rxBuf">*rxBuf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function executes a bit banged SPI transfer.
<br><br><code>&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;CS:&nbsp;0-31&nbsp;(as&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_spi_open">bb_spi_open</a>)<br>txBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;data&nbsp;to&nbsp;be&nbsp;sent<br>rxBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;returned&nbsp;data<br>count:&nbsp;size&nbsp;of&nbsp;data&nbsp;transfer<br></code><br><br>Returns &gt;= 0 if OK (the number of bytes read), otherwise
PI_BAD_USER_GPIO, PI_NOT_SPI_GPIO or PI_BAD_POINTER.
<br><br><b><small>Example</small></b><br><br><code>//&nbsp;gcc&nbsp;-Wall&nbsp;-pthread&nbsp;-o&nbsp;bb_spi_x_test&nbsp;bb_spi_x_test.c&nbsp;-lpigpiod_if2<br>//&nbsp;./bb_spi_x_test<br><br>#include&nbsp;&lt;stdio.h&gt;<br><br>#include&nbsp;"pigpiod_if2.h"<br><br>#define&nbsp;CE0&nbsp;5<br>#define&nbsp;CE1&nbsp;6<br>#define&nbsp;MISO&nbsp;13<br>#define&nbsp;MOSI&nbsp;19<br>#define&nbsp;SCLK&nbsp;12<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;pi,&nbsp;count,&nbsp;set_val,&nbsp;read_val;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;inBuf[3];<br>&nbsp;&nbsp;&nbsp;char&nbsp;cmd1[]&nbsp;=&nbsp;{0,&nbsp;0};<br>&nbsp;&nbsp;&nbsp;char&nbsp;cmd2[]&nbsp;=&nbsp;{12,&nbsp;0};<br>&nbsp;&nbsp;&nbsp;char&nbsp;cmd3[]&nbsp;=&nbsp;{1,&nbsp;128,&nbsp;0};<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;((pi&nbsp;=&nbsp;pigpio_start(0,&nbsp;0))&nbsp;&lt;&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"pigpio&nbsp;initialisation&nbsp;failed&nbsp;(%d).\n",&nbsp;pi);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;bb_spi_open(pi,&nbsp;CE0,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;10000,&nbsp;0);&nbsp;//&nbsp;MCP4251&nbsp;DAC<br>&nbsp;&nbsp;&nbsp;bb_spi_open(pi,&nbsp;CE1,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;20000,&nbsp;3);&nbsp;//&nbsp;MCP3008&nbsp;ADC<br><br>&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;256;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd1[1]&nbsp;=&nbsp;i;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;bb_spi_xfer(pi,&nbsp;CE0,&nbsp;cmd1,&nbsp;(char&nbsp;*)inBuf,&nbsp;2);&nbsp;//&nbsp;&gt;&nbsp;DAC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;==&nbsp;2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;bb_spi_xfer(pi,&nbsp;CE0,&nbsp;cmd2,&nbsp;(char&nbsp;*)inBuf,&nbsp;2);&nbsp;//&nbsp;&lt;&nbsp;DAC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;==&nbsp;2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_val&nbsp;=&nbsp;inBuf[1];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;bb_spi_xfer(pi,&nbsp;CE1,&nbsp;cmd3,&nbsp;(char&nbsp;*)inBuf,&nbsp;3);&nbsp;//&nbsp;&lt;&nbsp;ADC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;==&nbsp;3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read_val&nbsp;=&nbsp;((inBuf[1]&3)&lt;&lt;8)&nbsp;|&nbsp;inBuf[2];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;%d\n",&nbsp;set_val,&nbsp;read_val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;bb_spi_close(pi,&nbsp;CE0);<br>&nbsp;&nbsp;&nbsp;bb_spi_close(pi,&nbsp;CE1);<br><br>&nbsp;&nbsp;&nbsp;pigpio_stop(pi);<br>}<br></code><h3><a name="spi_open"></a><a href="#int"><small>int</small></a> spi_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#spi_channel">spi_channel</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#spi_flags">spi_flags</a>)</small></h3>
This function returns a handle for the SPI device on the channel.
Data will be transferred at baud bits per second.  The flags may
be used to modify the default behaviour of 4-wire operation, mode 0,
active low chip select.
<br><br>The Pi has two SPI peripherals: main and auxiliary.
<br><br>The main SPI has two chip selects (channels), the auxiliary has
three.
<br><br>The auxiliary SPI is available on all models but the A and B.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>MISO</td><td>MOSI</td><td>SCLK</td><td>CE0</td><td>CE1</td><td>CE2</td></tr><tr><td>Main SPI</td><td>9</td><td>10</td><td>11</td><td>8</td><td>7</td><td>-</td></tr><tr><td>Aux SPI</td><td>19</td><td>20</td><td>21</td><td>18</td><td>17</td><td>16</td></tr></tbody></table><br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>spi_channel:&nbsp;0-1&nbsp;(0-2&nbsp;for&nbsp;the&nbsp;auxiliary&nbsp;SPI).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;32K-125M&nbsp;(values&nbsp;above&nbsp;30M&nbsp;are&nbsp;unlikely&nbsp;to&nbsp;work).<br>&nbsp;&nbsp;spi_flags:&nbsp;see&nbsp;below.<br></code><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_BAD_SPI_CHANNEL,
PI_BAD_SPI_SPEED, PI_BAD_FLAGS, PI_NO_AUX_SPI, or PI_SPI_OPEN_FAILED.
<br><br>spi_flags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;W&nbsp;&nbsp;A&nbsp;u2&nbsp;u1&nbsp;u0&nbsp;p2&nbsp;p1&nbsp;p0&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode.
<br><br>Warning: modes 1 and 3 do not appear to work on the auxiliary SPI.
<br><br><code>Mode&nbsp;POL&nbsp;PHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1<br></code><br><br>px is 0 if CEx is active low (default) and 1 for active high.
<br><br>ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.
<br><br>A is 0 for the main SPI, 1 for the auxiliary SPI.
<br><br>W is 0 if the device is not 3-wire, 1 if the device is 3-wire.  Main
SPI only.
<br><br>nnnn defines the number of bytes (0-15) to write before switching
the MOSI line to MISO to read data.  This field is ignored
if W is not set.  Main SPI only.
<br><br>T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.  Auxiliary SPI
only.
<br><br>R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.  Auxiliary SPI
only.
<br><br>bbbbbb defines the word size in bits (0-32).  The default (0)
sets 8 bits per word.  Auxiliary SPI only.
<br><br>The <a href="#spi_read">spi_read</a>, <a href="#spi_write">spi_write</a>, and <a href="#spi_xfer">spi_xfer</a> functions
transfer data packed into 1, 2, or 4 bytes according to
the word size in bits.
<br><br>For bits 1-8 there will be one byte per character.<br>
For bits 9-16 there will be two bytes per character.<br>
For bits 17-32 there will be four bytes per character.
<br><br>Multi-byte transfers are made in least significant byte first order.
<br><br>E.g. to transfer 32 11-bit words buf should contain 64 bytes
and count should be 64.
<br><br>E.g. to transfer the 14 bit value 0x1ABC send the bytes 0xBC followed
by 0x1A.
<br><br>The other bits in flags should be set to zero.
<h3><a name="spi_close"></a><a href="#int"><small>int</small></a> spi_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This functions closes the SPI device identified by the handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<h3><a name="spi_read"></a><a href="#int"><small>int</small></a> spi_read<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function reads count bytes of data from the SPI
device associated with the handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>.<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data&nbsp;bytes.<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></code><br><br>Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.
<h3><a name="spi_write"></a><a href="#int"><small>int</small></a> spi_write<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function writes count bytes of data from buf to the SPI
device associated with the handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>.<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;write.<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br></code><br><br>Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.
<h3><a name="spi_xfer"></a><a href="#int"><small>int</small></a> spi_xfer<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*txBuf">*txBuf</a>, <a href="#char">char</a> <a href="#*rxBuf">*rxBuf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function transfers count bytes of data from txBuf to the SPI
device associated with the handle.  Simultaneously count bytes of
data are read from the device and placed in rxBuf.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>.<br>&nbsp;txBuf:&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;write.<br>&nbsp;rxBuf:&nbsp;the&nbsp;received&nbsp;data&nbsp;bytes.<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;transfer.<br></code><br><br>Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.
<h3><a name="serial_open"></a><a href="#int"><small>int</small></a> serial_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#char">char</a> <a href="#*ser_tty">*ser_tty</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#ser_flags">ser_flags</a>)</small></h3>
This function opens a serial device at a specified baud rate
with specified flags.  The device name must start with
/dev/tty or /dev/serial.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;ser_tty:&nbsp;the&nbsp;serial&nbsp;device&nbsp;to&nbsp;open.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;the&nbsp;baud&nbsp;rate&nbsp;in&nbsp;bits&nbsp;per&nbsp;second,&nbsp;see&nbsp;below.<br>ser_flags:&nbsp;0.<br></code><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE, or
PI_SER_OPEN_FAILED.
<br><br>The baud rate must be one of 50, 75, 110, 134, 150,
200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200,
38400, 57600, 115200, or 230400.
<br><br>No flags are currently defined.  This parameter should be set to zero.
<h3><a name="serial_close"></a><a href="#int"><small>int</small></a> serial_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function closes the serial device associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<h3><a name="serial_write_byte"></a><a href="#int"><small>int</small></a> serial_write_byte<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#bVal">bVal</a>)</small></h3>
This function writes bVal to the serial port associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_SER_WRITE_FAILED.
<h3><a name="serial_read_byte"></a><a href="#int"><small>int</small></a> serial_read_byte<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function reads a byte from the serial port associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>.<br></code><br><br>Returns the read byte (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_SER_READ_NO_DATA, or PI_SER_READ_FAILED.
<br><br>If no data is ready PI_SER_READ_NO_DATA is returned.
<h3><a name="serial_write"></a><a href="#int"><small>int</small></a> serial_write<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function writes count bytes from buf to the the serial port
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>.<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;array&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_SER_WRITE_FAILED.
<h3><a name="serial_read"></a><a href="#int"><small>int</small></a> serial_read<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function reads up to count bytes from the the serial port
associated with handle and writes them to buf.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>.<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data.<br>&nbsp;count:&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></code><br><br>Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, PI_SER_READ_NO_DATA, or PI_SER_WRITE_FAILED.
<br><br>If no data is ready zero is returned.
<h3><a name="serial_data_available"></a><a href="#int"><small>int</small></a> serial_data_available<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
Returns the number of bytes available to be read from the
device associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>.<br></code><br><br>Returns the number of bytes of data available (&gt;=0) if OK,
otherwise PI_BAD_HANDLE.
<h3><a name="custom_1"></a><a href="#int"><small>int</small></a> custom_1<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#arg1">arg1</a>, <a href="#unsigned">unsigned</a> <a href="#arg2">arg2</a>, <a href="#char">char</a> <a href="#*argx">*argx</a>, <a href="#unsigned">unsigned</a> <a href="#argc">argc</a>)</small></h3>
This function is available for user customisation.
<br><br>It returns a single integer value.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>arg1:&nbsp;&gt;=0<br>arg2:&nbsp;&gt;=0<br>argx:&nbsp;extra&nbsp;(byte)&nbsp;arguments<br>argc:&nbsp;number&nbsp;of&nbsp;extra&nbsp;arguments<br></code><br><br>Returns &gt;= 0 if OK, less than 0 indicates a user defined error.
<h3><a name="custom_2"></a><a href="#int"><small>int</small></a> custom_2<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#arg1">arg1</a>, <a href="#char">char</a> <a href="#*argx">*argx</a>, <a href="#unsigned">unsigned</a> <a href="#argc">argc</a>, <a href="#char">char</a> <a href="#*retBuf">*retBuf</a>, <a href="#unsigned">unsigned</a> <a href="#retMax">retMax</a>)</small></h3>
This function is available for user customisation.
<br><br>It differs from custom_1 in that it returns an array of bytes
rather than just an integer.
<br><br>The return value is an integer indicating the number of returned bytes.
<code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;arg1:&nbsp;&gt;=0<br>&nbsp;&nbsp;argc:&nbsp;extra&nbsp;(byte)&nbsp;arguments<br>&nbsp;count:&nbsp;number&nbsp;of&nbsp;extra&nbsp;arguments<br>retBuf:&nbsp;buffer&nbsp;for&nbsp;returned&nbsp;data<br>retMax:&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;return<br></code><br><br>Returns &gt;= 0 if OK, less than 0 indicates a user defined error.
<br><br>Note, the number of returned bytes will be retMax or less.
<h3><a name="get_pad_strength"></a><a href="#int"><small>int</small></a> get_pad_strength<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#pad">pad</a>)</small></h3>
This function returns the pad drive strength in mA.
<br><br><code>&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>pad:&nbsp;0-2,&nbsp;the&nbsp;pad&nbsp;to&nbsp;get.<br></code><br><br>Returns the pad drive strength if OK, otherwise PI_BAD_PAD.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>strength&nbsp;=&nbsp;get_pad_strength(pi,&nbsp;0);&nbsp;//&nbsp;&nbsp;get&nbsp;pad&nbsp;0&nbsp;strength<br></code><h3><a name="set_pad_strength"></a><a href="#int"><small>int</small></a> set_pad_strength<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#pad">pad</a>, <a href="#unsigned">unsigned</a> <a href="#padStrength">padStrength</a>)</small></h3>
This function sets the pad drive strength in mA.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pad:&nbsp;0-2,&nbsp;the&nbsp;pad&nbsp;to&nbsp;set.<br>padStrength:&nbsp;1-16&nbsp;mA.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_PAD, or PI_BAD_STRENGTH.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>set_pad_strength(pi,&nbsp;0,&nbsp;10);&nbsp;//&nbsp;set&nbsp;pad&nbsp;0&nbsp;strength&nbsp;to&nbsp;10&nbsp;mA<br></code><h3><a name="shell_"></a><a href="#int"><small>int</small></a> shell_<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#char">char</a> <a href="#*scriptName">*scriptName</a>, <a href="#char">char</a> <a href="#*scriptString">*scriptString</a>)</small></h3>
This function uses the system call to execute a shell script
with the given string as its parameter.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;scriptName:&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;script,&nbsp;only&nbsp;alphanumeric&nbsp;characters,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'-'&nbsp;and&nbsp;'_'&nbsp;are&nbsp;allowed&nbsp;in&nbsp;the&nbsp;name.<br>scriptString:&nbsp;the&nbsp;string&nbsp;to&nbsp;pass&nbsp;to&nbsp;the&nbsp;script.<br></code><br><br>The exit status of the system call is returned if OK, otherwise
PI_BAD_SHELL_STATUS.
<br><br>scriptName must exist in /opt/pigpio/cgi and must be executable.
<br><br>The returned exit status is normally 256 times that set by the
shell script exit function.  If the script can't be found 32512 will
be returned.
<br><br>The following table gives some example returned statuses.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Script exit status</td><td>Returned system call status</td></tr><tr><td>1</td><td>256</td></tr><tr><td>5</td><td>1280</td></tr><tr><td>10</td><td>2560</td></tr><tr><td>200</td><td>51200</td></tr><tr><td>script not found</td><td>32512</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>//&nbsp;pass&nbsp;two&nbsp;parameters,&nbsp;hello&nbsp;and&nbsp;world<br>status&nbsp;=&nbsp;shell_(pi,&nbsp;"scr1",&nbsp;"hello&nbsp;world");<br><br>//&nbsp;pass&nbsp;three&nbsp;parameters,&nbsp;hello,&nbsp;string&nbsp;with&nbsp;spaces,&nbsp;and&nbsp;world<br>status&nbsp;=&nbsp;shell_(pi,&nbsp;"scr1",&nbsp;"hello&nbsp;'string&nbsp;with&nbsp;spaces'&nbsp;world");<br><br>//&nbsp;pass&nbsp;one&nbsp;parameter,&nbsp;hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world<br>status&nbsp;=&nbsp;shell_(pi,&nbsp;"scr1",&nbsp;"\"hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world\"");<br></code><h3><a name="file_open"></a><a href="#int"><small>int</small></a> file_open<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#char">char</a> <a href="#*file">*file</a>, <a href="#unsigned">unsigned</a> <a href="#mode">mode</a>)</small></h3>
This function returns a handle to a file opened in a specified mode.
<br><br><code>&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>file:&nbsp;the&nbsp;file&nbsp;to&nbsp;open.<br>mode:&nbsp;the&nbsp;file&nbsp;open&nbsp;mode.<br></code><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE, PI_NO_FILE_ACCESS,
PI_BAD_FILE_MODE, PI_FILE_OPEN_FAILED, or PI_FILE_IS_A_DIR.
<br><br>File
<br><br>A file may only be opened if permission is granted by an entry in
/opt/pigpio/access.  This is intended to allow remote access to files
in a more or less controlled manner.
<br><br>Each entry in /opt/pigpio/access takes the form of a file path
which may contain wildcards followed by a single letter permission.
The permission may be R for read, W for write, U for read/write,
and N for no access.
<br><br>Where more than one entry matches a file the most specific rule
applies.  If no entry matches a file then access is denied.
<br><br>Suppose /opt/pigpio/access contains the following entries
<br><br><code>/home/*&nbsp;n<br>/home/pi/shared/dir_1/*&nbsp;w<br>/home/pi/shared/dir_2/*&nbsp;r<br>/home/pi/shared/dir_3/*&nbsp;u<br>/home/pi/shared/dir_1/file.txt&nbsp;n<br></code><br><br>Files may be written in directory dir_1 with the exception
of file.txt.
<br><br>Files may be read in directory dir_2.
<br><br>Files may be read and written in directory dir_3.
<br><br>If a directory allows read, write, or read/write access then files may
be created in that directory.
<br><br>In an attempt to prevent risky permissions the following paths are
ignored in /opt/pigpio/access.
<br><br><code>a&nbsp;path&nbsp;containing&nbsp;..<br>a&nbsp;path&nbsp;containing&nbsp;only&nbsp;wildcards&nbsp;(*?)<br>a&nbsp;path&nbsp;containing&nbsp;less&nbsp;than&nbsp;two&nbsp;non-wildcard&nbsp;parts<br></code><br><br>Mode
<br><br>The mode may have the following values.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Macro</td><td>Value</td><td>Meaning</td></tr><tr><td>PI_FILE_READ</td><td>1</td><td>open file for reading</td></tr><tr><td>PI_FILE_WRITE</td><td>2</td><td>open file for writing</td></tr><tr><td>PI_FILE_RW</td><td>3</td><td>open file for reading and writing</td></tr></tbody></table><br><br>The following values may be or'd into the mode.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Macro</td><td>Value</td><td>Meaning</td></tr><tr><td>PI_FILE_APPEND</td><td>4</td><td>Writes append data to the end of the file</td></tr><tr><td>PI_FILE_CREATE</td><td>8</td><td>The file is created if it doesn't exist</td></tr><tr><td>PI_FILE_TRUNC</td><td>16</td><td>The file is truncated</td></tr></tbody></table><br><br>Newly created files are owned by root with permissions owner read and write.
<br><br><b><small>Example</small></b><br><br><code>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;pigpiod_if2.h&gt;<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;pi,&nbsp;handle,&nbsp;c;<br>&nbsp;&nbsp;&nbsp;char&nbsp;buf[60000];<br><br>&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;pigpio_start(NULL,&nbsp;NULL);<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(pi&nbsp;&lt;&nbsp;0)&nbsp;return&nbsp;1;<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;assumes&nbsp;/opt/pigpio/access&nbsp;contains&nbsp;the&nbsp;following&nbsp;line<br>&nbsp;&nbsp;&nbsp;//&nbsp;/ram/*.c&nbsp;r<br><br>&nbsp;&nbsp;&nbsp;handle&nbsp;=&nbsp;file_open(pi,&nbsp;"/ram/pigpio.c",&nbsp;PI_FILE_READ);<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(handle&nbsp;&gt;=&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((c=file_read(pi,&nbsp;handle,&nbsp;buf,&nbsp;sizeof(buf)-1)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[c]&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s",&nbsp;buf);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file_close(pi,&nbsp;handle);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;pigpio_stop(pi);<br>}<br></code><h3><a name="file_close"></a><a href="#int"><small>int</small></a> file_close<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function closes the file associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#file_open">file_open</a>).<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br><b><small>Example</small></b><br><br><code>file_close(pi,&nbsp;handle);<br></code><h3><a name="file_write"></a><a href="#int"><small>int</small></a> file_write<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function writes count bytes from buf to the the file
associated with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#file_open">file_open</a>).<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;array&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM,
PI_FILE_NOT_WOPEN, or PI_BAD_FILE_WRITE.
<br><br><b><small>Example</small></b><br><br><code>if&nbsp;(file_write(pi,&nbsp;handle,&nbsp;buf,&nbsp;100)&nbsp;==&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;file&nbsp;written&nbsp;okay<br>}<br>else<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;error<br>}<br></code><h3><a name="file_read"></a><a href="#int"><small>int</small></a> file_read<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function reads up to count bytes from the the file
associated with handle and writes them to buf.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>handle:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#file_open">file_open</a>).<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data.<br>&nbsp;count:&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></code><br><br>Returns the number of bytes read (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, PI_FILE_NOT_ROPEN, or PI_BAD_FILE_WRITE.
<br><br><b><small>Example</small></b><br><br><code>&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;file_read(pi,&nbsp;handle,&nbsp;buf,&nbsp;sizeof(buf));<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(bytes&nbsp;&gt;=&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;process&nbsp;read&nbsp;data<br>&nbsp;&nbsp;&nbsp;}<br></code><h3><a name="file_seek"></a><a href="#int"><small>int</small></a> file_seek<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#int32_t">int32_t</a> <a href="#seekOffset">seekOffset</a>, <a href="#int">int</a> <a href="#seekFrom">seekFrom</a>)</small></h3>
This function seeks to a position within the file associated
with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;handle:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#file_open">file_open</a>).<br>seekOffset:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;move.&nbsp;&nbsp;Positive&nbsp;offsets<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;forward,&nbsp;negative&nbsp;offsets&nbsp;backwards.<br>&nbsp;&nbsp;seekFrom:&nbsp;one&nbsp;of&nbsp;PI_FROM_START&nbsp;(0),&nbsp;PI_FROM_CURRENT&nbsp;(1),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;PI_FROM_END&nbsp;(2).<br></code><br><br>Returns the new byte position within the file (&gt;=0) if OK, otherwise PI_BAD_HANDLE, or PI_BAD_FILE_SEEK.
<br><br><b><small>Example</small></b><br><br><code>file_seek(pi,&nbsp;handle,&nbsp;123,&nbsp;PI_FROM_START);&nbsp;//&nbsp;Start&nbsp;plus&nbsp;123<br><br>size&nbsp;=&nbsp;file_seek(pi,&nbsp;handle,&nbsp;0,&nbsp;PI_FROM_END);&nbsp;//&nbsp;End,&nbsp;return&nbsp;size<br><br>pos&nbsp;=&nbsp;file_seek(pi,&nbsp;handle,&nbsp;0,&nbsp;PI_FROM_CURRENT);&nbsp;//&nbsp;Current&nbsp;position<br></code><h3><a name="file_list"></a><a href="#int"><small>int</small></a> file_list<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#char">char</a> <a href="#*fpat">*fpat</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function returns a list of files which match a pattern.
<br><br><code>&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;fpat:&nbsp;file&nbsp;pattern&nbsp;to&nbsp;match.<br>&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;matching&nbsp;file&nbsp;names.<br>count:&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></code><br><br>Returns the number of returned bytes if OK, otherwise PI_NO_FILE_ACCESS,
or PI_NO_FILE_MATCH.
<br><br>The pattern must match an entry in /opt/pigpio/access.  The pattern
may contain wildcards.  See <a href="#file_open">file_open</a>.
<br><br>NOTE
<br><br>The returned value is not the number of files, it is the number
of bytes in the buffer.  The file names are separated by newline
characters.
<br><br><b><small>Example</small></b><br><br><code>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;pigpiod_if2.h&gt;<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;pi,&nbsp;handle,&nbsp;c;<br>&nbsp;&nbsp;&nbsp;char&nbsp;buf[60000];<br><br>&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;pigpio_start(NULL,&nbsp;NULL);<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(pi&nbsp;&lt;&nbsp;0)&nbsp;return&nbsp;1;<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;assumes&nbsp;/opt/pigpio/access&nbsp;contains&nbsp;the&nbsp;following&nbsp;line<br>&nbsp;&nbsp;&nbsp;//&nbsp;/ram/*.c&nbsp;r<br><br>&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;file_list(pi,&nbsp;"/ram/p*.c",&nbsp;buf,&nbsp;sizeof(buf));<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;&gt;=&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[c]&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s",&nbsp;buf);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;pigpio_stop(pi);<br>}<br></code><h3><a name="callback"></a><a href="#int"><small>int</small></a> callback<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#edge">edge</a>, <a href="#CBFunc_t">CBFunc_t</a> <a href="#f">f</a>)</small></h3>
This function initialises a new callback.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge:&nbsp;RISING_EDGE,&nbsp;FALLING_EDGE,&nbsp;or&nbsp;EITHER_EDGE.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function.<br></code><br><br>The function returns a callback id if OK, otherwise pigif_bad_malloc,
pigif_duplicate_callback, or pigif_bad_callback.
<br><br>The callback is called with the GPIO, edge, and tick, whenever the
GPIO has the identified edge.
<br><br><code>Parameter&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;Meaning<br><br>GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;GPIO&nbsp;which&nbsp;has&nbsp;changed&nbsp;state<br><br>edge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;change&nbsp;to&nbsp;low&nbsp;(a&nbsp;falling&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;change&nbsp;to&nbsp;high&nbsp;(a&nbsp;rising&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&nbsp;no&nbsp;level&nbsp;change&nbsp;(a&nbsp;watchdog&nbsp;timeout)<br><br>tick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;bit&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;since&nbsp;boot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;this&nbsp;wraps&nbsp;around&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4294967295&nbsp;to&nbsp;0&nbsp;roughly&nbsp;every&nbsp;72&nbsp;minutes<br></code><br><br>The GPIO are sampled at a rate set when the pigpio daemon
is started (default 5 us).
<br><br>The number of samples per second is given in the following table.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;samples<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;per&nbsp;sec<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1,000,000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;500,000<br>sample&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;250,000<br>rate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;200,000<br>(us)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;125,000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;100,000<br></code><br><br>GPIO level changes shorter than the sample rate may be missed.
<br><br>The daemon software which generates the callbacks is triggered
1000 times per second.  The callbacks will be called once per
level change since the last time they were called.
i.e. The callbacks will get all level changes but there will
be a latency.
<br><br>If you want to track the level of more than one GPIO do so by
maintaining the state in the callback.  Do not use <a href="#gpio_read">gpio_read</a>.
Remember the event that triggered the callback may have
happened several milliseconds before and the GPIO may have
changed level many times since then.
<h3><a name="callback_ex"></a><a href="#int"><small>int</small></a> callback_ex<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#edge">edge</a>, <a href="#CBFuncEx_t">CBFuncEx_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
This function initialises a new callback.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge:&nbsp;RISING_EDGE,&nbsp;FALLING_EDGE,&nbsp;or&nbsp;EITHER_EDGE.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function.<br>&nbsp;userdata:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data.<br></code><br><br>The function returns a callback id if OK, otherwise pigif_bad_malloc,
pigif_duplicate_callback, or pigif_bad_callback.
<br><br>The callback is called with the GPIO, edge, tick, and the userdata
pointer, whenever the GPIO has the identified edge.
<br><br><code>Parameter&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;Meaning<br><br>GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;GPIO&nbsp;which&nbsp;has&nbsp;changed&nbsp;state<br><br>edge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;change&nbsp;to&nbsp;low&nbsp;(a&nbsp;falling&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;change&nbsp;to&nbsp;high&nbsp;(a&nbsp;rising&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&nbsp;no&nbsp;level&nbsp;change&nbsp;(a&nbsp;watchdog&nbsp;timeout)<br><br>tick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;bit&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;since&nbsp;boot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;this&nbsp;wraps&nbsp;around&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4294967295&nbsp;to&nbsp;0&nbsp;roughly&nbsp;every&nbsp;72&nbsp;minutes<br><br>userdata&nbsp;&nbsp;&nbsp;&nbsp;pointer&nbsp;&nbsp;Pointer&nbsp;to&nbsp;an&nbsp;arbitrary&nbsp;object<br></code><h3><a name="callback_cancel"></a><a href="#int"><small>int</small></a> callback_cancel<small>(<a href="#unsigned">unsigned</a> <a href="#callback_id">callback_id</a>)</small></h3>
This function cancels a callback identified by its id.
<br><br><code>callback_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#callback">callback</a>&nbsp;or&nbsp;<a href="#callback_ex">callback_ex</a>.<br></code><br><br>The function returns 0 if OK, otherwise pigif_callback_not_found.
<h3><a name="wait_for_edge"></a><a href="#int"><small>int</small></a> wait_for_edge<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#edge">edge</a>, <a href="#double">double</a> <a href="#timeout">timeout</a>)</small></h3>
This function waits for an edge on the GPIO for up to timeout
seconds.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>user_gpio:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge:&nbsp;RISING_EDGE,&nbsp;FALLING_EDGE,&nbsp;or&nbsp;EITHER_EDGE.<br>&nbsp;&nbsp;timeout:&nbsp;&gt;=0.<br></code><br><br>The function returns when the edge occurs or after the timeout.
<br><br>Do not use this function for precise timing purposes,
the edge is only checked 20 times a second. Whenever
you need to know the accurate time of GPIO events use
a <a href="#callback">callback</a> function.
<br><br>The function returns 1 if the edge occurred, otherwise 0.
<h3><a name="bsc_xfer"></a><a href="#int"><small>int</small></a> bsc_xfer<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#bsc_xfer_t">bsc_xfer_t</a> <a href="#*bscxfer">*bscxfer</a>)</small></h3>
This function provides a low-level interface to the SPI/I2C Slave
peripheral on the BCM chip.
<br><br>This peripheral allows the Pi to act as a hardware slave device
on an I2C or SPI bus.
<br><br>This is not a bit bang version and as such is OS timing
independent. The bus timing is handled directly by the chip.
<br><br>The output process is simple. You simply append data to the FIFO
buffer on the chip.  This works like a queue, you add data to the
queue and the master removes it.
<br><br>I can't get SPI to work properly.  I tried with a
control word of 0x303 and swapped MISO and MOSI.
<br><br>The function sets the BSC mode, writes any data in
the transmit buffer to the BSC transmit FIFO, and
copies any data in the BSC receive FIFO to the
receive buffer.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>bscxfer:&nbsp;a&nbsp;structure&nbsp;defining&nbsp;the&nbsp;transfer.<br><br>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;control;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;int&nbsp;rxCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;char&nbsp;rxBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;int&nbsp;txCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;char&nbsp;txBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Write<br>}&nbsp;bsc_xfer_t;<br></code><br><br>To start a transfer set control (see below), copy the bytes to
be added to the transmit FIFO (if any) to txBuf and set txCnt to
the number of copied bytes.
<br><br>Upon return rxCnt will be set to the number of received bytes placed
in rxBuf.
<br><br>The returned function value is the status of the transfer (see below).
<br><br>If there was an error the status will be less than zero
(and will contain the error code).
<br><br>The most significant word of the returned status contains the number
of bytes actually copied from txBuf to the BSC transmit FIFO (may be
less than requested if the FIFO already contained untransmitted data).
<br><br>Note that the control word sets the BSC mode.  The BSC will stay in
that mode until a different control word is sent.
<br><br>GPIO used for models other than those based on the BCM2711.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>18</td><td>19</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>18</td><td>19</td><td>20</td><td>21</td></tr></tbody></table><br><br>GPIO used for models based on the BCM2711 (e.g. the Pi4B).
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>10</td><td>11</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>10</td><td>11</td><td>9</td><td>8</td></tr></tbody></table><br><br>When a zero control word is received the used GPIO will be reset
to INPUT mode.
<br><br>control consists of the following bits.
<br><br><code>22&nbsp;21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;IT&nbsp;HC&nbsp;TF&nbsp;IR&nbsp;RE&nbsp;TE&nbsp;BK&nbsp;EC&nbsp;ES&nbsp;PL&nbsp;PH&nbsp;I2&nbsp;SP&nbsp;EN<br></code><br><br>Bits 0-13 are copied unchanged to the BSC CR register.  See
pages 163-165 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>aaaaaaa</td><td>defines the I2C slave address (only relevant in I2C mode)</td></tr><tr><td>IT</td><td>invert transmit status flags</td></tr><tr><td>HC</td><td>enable host control</td></tr><tr><td>TF</td><td>enable test FIFO</td></tr><tr><td>IR</td><td>invert receive status flags</td></tr><tr><td>RE</td><td>enable receive</td></tr><tr><td>TE</td><td>enable transmit</td></tr><tr><td>BK</td><td>abort operation and clear FIFOs</td></tr><tr><td>EC</td><td>send control register as first I2C byte</td></tr><tr><td>ES</td><td>send status register as first I2C byte</td></tr><tr><td>PL</td><td>set SPI polarity high</td></tr><tr><td>PH</td><td>set SPI phase high</td></tr><tr><td>I2</td><td>enable I2C mode</td></tr><tr><td>SP</td><td>enable SPI mode</td></tr><tr><td>EN</td><td>enable BSC peripheral</td></tr></tbody></table><br><br>The returned status has the following format
<br><br><code>20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;RB&nbsp;TE&nbsp;RF&nbsp;TF&nbsp;RE&nbsp;TB<br></code><br><br>Bits 0-15 are copied unchanged from the BSC FR register.  See
pages 165-166 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>SSSSS</td><td>number of bytes successfully copied to transmit FIFO</td></tr><tr><td>RRRRR</td><td>number of bytes in receieve FIFO</td></tr><tr><td>TTTTT</td><td>number of bytes in transmit FIFO</td></tr><tr><td>RB</td><td>receive busy</td></tr><tr><td>TE</td><td>transmit FIFO empty</td></tr><tr><td>RF</td><td>receive FIFO full</td></tr><tr><td>TF</td><td>transmit FIFO full</td></tr><tr><td>RE</td><td>receive FIFO empty</td></tr><tr><td>TB</td><td>transmit busy</td></tr></tbody></table><br><br>The following example shows how to configure the BSC peripheral as
an I2C slave with address 0x13 and send four bytes.
<br><br><b><small>Example</small></b><br><br><code>bsc_xfer_t&nbsp;xfer;<br><br>xfer.control&nbsp;=&nbsp;(0x13&lt;&lt;16)&nbsp;|&nbsp;0x305;<br><br>memcpy(xfer.txBuf,&nbsp;"ABCD",&nbsp;4);<br>xfer.txCnt&nbsp;=&nbsp;4;<br><br>status&nbsp;=&nbsp;bsc_xfer(pi,&nbsp;&xfer);<br><br>if&nbsp;(status&nbsp;&gt;=&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;process&nbsp;transfer<br>}<br></code><h3><a name="bsc_i2c"></a><a href="#int"><small>int</small></a> bsc_i2c<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#int">int</a> <a href="#i2c_addr">i2c_addr</a>, <a href="#bsc_xfer_t">bsc_xfer_t</a> <a href="#*bscxfer">*bscxfer</a>)</small></h3>
This function allows the Pi to act as a slave I2C device.
<br><br>This function is not available on the BCM2711 (e.g.as
used in the Pi4B).
<br><br>The data bytes (if any) are written to the BSC transmit
FIFO and the bytes in the BSC receive FIFO are returned.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>i2c_addr:&nbsp;0-0x7F.<br>&nbsp;bscxfer:&nbsp;a&nbsp;structure&nbsp;defining&nbsp;the&nbsp;transfer.<br><br>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;control;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;N/A<br>&nbsp;&nbsp;&nbsp;int&nbsp;rxCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;char&nbsp;rxBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;int&nbsp;txCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;char&nbsp;txBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Write<br>}&nbsp;bsc_xfer_t;<br></code><br><br>txCnt is set to the number of bytes to be transmitted, possibly
zero. The data itself should be copied to txBuf.
<br><br>Any received data will be written to rxBuf with rxCnt set.
<br><br>See <a href="#bsc_xfer">bsc_xfer</a> for details of the returned status value.
<br><br>If there was an error the status will be less than zero
(and will contain the error code).
<br><br>Note that an i2c_address of 0 may be used to close
the BSC device and reassign the used GPIO as inputs.
<h3><a name="event_callback"></a><a href="#int"><small>int</small></a> event_callback<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#event">event</a>, <a href="#evtCBFunc_t">evtCBFunc_t</a> <a href="#f">f</a>)</small></h3>
This function initialises an event callback.
<br><br><code>&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>event:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function.<br></code><br><br>The function returns a callback id if OK, otherwise pigif_bad_malloc,
pigif_duplicate_callback, or pigif_bad_callback.
<br><br>The callback is called with the event id, and tick, whenever the
event occurs.
<h3><a name="event_callback_ex"></a><a href="#int"><small>int</small></a> event_callback_ex<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#event">event</a>, <a href="#evtCBFuncEx_t">evtCBFuncEx_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
This function initialises an event callback.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;&nbsp;event:&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function.<br>userdata:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data.<br></code><br><br>The function returns a callback id if OK, otherwise pigif_bad_malloc,
pigif_duplicate_callback, or pigif_bad_callback.
<br><br>The callback is called with the event id, the tick, and the userdata
pointer whenever the event occurs.
<h3><a name="event_callback_cancel"></a><a href="#int"><small>int</small></a> event_callback_cancel<small>(<a href="#unsigned">unsigned</a> <a href="#callback_id">callback_id</a>)</small></h3>
This function cancels an event callback identified by its id.
<br><br><code>callback_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#event_callback">event_callback</a>&nbsp;or<br><a href="#event_callback_ex">event_callback_ex</a>.<br></code><br><br>The function returns 0 if OK, otherwise pigif_callback_not_found.
<h3><a name="wait_for_event"></a><a href="#int"><small>int</small></a> wait_for_event<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#event">event</a>, <a href="#double">double</a> <a href="#timeout">timeout</a>)</small></h3>
This function waits for an event for up to timeout seconds.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>&nbsp;&nbsp;event:&nbsp;0-31.<br>timeout:&nbsp;&gt;=0.<br></code><br><br>The function returns when the event occurs or after the timeout.
<br><br>The function returns 1 if the event occurred, otherwise 0.
<h3><a name="event_trigger"></a><a href="#int"><small>int</small></a> event_trigger<small>(<a href="#int">int</a> <a href="#pi">pi</a>, <a href="#unsigned">unsigned</a> <a href="#event">event</a>)</small></h3>
This function signals the occurrence of an event.
<br><br><code>&nbsp;&nbsp;&nbsp;pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br>event:&nbsp;0-31.<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_EVENT_ID.
<br><br>An event is a signal used to inform one or more consumers
to start an action.  Each consumer which has registered an interest
in the event (e.g. by calling <a href="#event_callback">event_callback</a>) will be informed by
a callback.
<br><br>One event, PI_EVENT_BSC (31) is predefined.  This event is
auto generated on BSC slave activity.
<br><br>The meaning of other events is arbitrary.
<br><br>Note that other than its id and its tick there is no data associated
with an event.
<h2>PARAMETERS</h2><h3><a name="active">active</a>: 0-1000000</h3>
The number of microseconds level changes are reported for once
a noise filter has been triggered (by <a href="#steady">steady</a> microseconds of
a stable level).
<h3><a name="*addrStr">*addrStr</a></h3>
A string specifying the host or IP address of the Pi running
the pigpio daemon.  It may be NULL in which case localhost
is used unless overridden by the PIGPIO_ADDR environment
variable.
<h3><a name="arg1">arg1</a></h3>
An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.
<h3><a name="arg2">arg2</a></h3>
An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.
<h3><a name="argc">argc</a></h3>
The count of bytes passed to a user customised function.
<h3><a name="*argx">*argx</a></h3>
A pointer to an array of bytes passed to a user customised function.
Its meaning and content is defined by the customiser.
<h3><a name="baud">baud</a></h3>
The speed of serial communication (I2C, SPI, serial link, waves) in
bits per second.
<h3><a name="bit">bit</a></h3>
A value of 0 or 1.
<h3><a name="bits">bits</a></h3>
A value used to select GPIO.  If bit n of bits is set then GPIO n is
selected.
<br><br>A convenient way to set bit n is to or in (1&lt;&lt;n).
<br><br>e.g. to select bits 5, 9, 23 you could use (1&lt;&lt;5) | (1&lt;&lt;9) | (1&lt;&lt;23).
<h3><a name="bsc_xfer_t">bsc_xfer_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;control;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;int&nbsp;rxCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;char&nbsp;rxBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;int&nbsp;txCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;char&nbsp;txBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Write<br>}&nbsp;bsc_xfer_t;<br></code><h3><a name="*bscxfer">*bscxfer</a></h3>
A pointer to a <a href="#bsc_xfer_t">bsc_xfer_t</a> object used to control a BSC transfer.
<h3><a name="*buf">*buf</a></h3>
A buffer to hold data being sent or being received.
<h3><a name="bufSize">bufSize</a></h3>
The size in bytes of a buffer.
<h3><a name="bVal">bVal</a>: 0-255 (Hex 0x0-0xFF, Octal 0-0377)</h3>
An 8-bit byte value.
<h3><a name="callback_id">callback_id</a></h3>
A value &gt;=0, as returned by a call to a callback function, one of
<br><br><a href="#callback">callback</a><br>
<a href="#callback_ex">callback_ex</a><br>
<a href="#event_callback">event_callback</a><br>
<a href="#event_callback_ex">event_callback_ex</a>
<br><br>The id is passed to <a href="#callback_cancel">callback_cancel</a> or <a href="#event_callback_cancel">event_callback_cancel</a>
to cancel the callback.
<h3><a name="CBFunc_t">CBFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*CBFunc_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;pi,&nbsp;unsigned&nbsp;user_gpio,&nbsp;unsigned&nbsp;level,&nbsp;uint32_t&nbsp;tick);<br></code><h3><a name="CBFuncEx_t">CBFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*CBFuncEx_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;pi,&nbsp;unsigned&nbsp;user_gpio,&nbsp;unsigned&nbsp;level,&nbsp;uint32_t&nbsp;tick,&nbsp;void&nbsp;*&nbsp;userdata);<br></code><h3><a name="char">char</a></h3>
A single character, an 8 bit quantity able to store 0-255.
<h3><a name="clkfreq">clkfreq</a>: 4689-250M (13184-375M for the BCM2711)</h3>
The hardware clock frequency.
<h3><a name="count">count</a></h3>
The number of bytes to be transferred in a file, I2C, SPI, or serial
command.
<h3><a name="CS">CS</a></h3>
The GPIO used for the slave select signal when bit banging SPI.
<h3><a name="data_bits">data_bits</a>: 1-32</h3>
The number of data bits in each character of serial data.
<br><br><code>#define&nbsp;PI_MIN_WAVE_DATABITS&nbsp;1<br>#define&nbsp;PI_MAX_WAVE_DATABITS&nbsp;32<br></code><h3><a name="double">double</a></h3>
A floating point number.
<h3><a name="dutycycle">dutycycle</a>: 0-range</h3>
A number representing the ratio of on time to off time for PWM.
<br><br>The number may vary between 0 and range (default 255) where
0 is off and range is fully on.
<h3><a name="edge">edge</a></h3>
Used to identify a GPIO level transition of interest.  A rising edge is
a level change from 0 to 1.  A falling edge is a level change from 1 to 0.
<br><br><code>RISING_EDGE&nbsp;&nbsp;0<br>FALLING_EDGE&nbsp;1<br>EITHER_EDGE.&nbsp;2<br></code><h3><a name="errnum">errnum</a></h3>
A negative number indicating a function call failed and the nature
of the error.
<h3><a name="event">event</a>: 0-31</h3>
An event is a signal used to inform one or more consumers
to start an action.
<h3><a name="evtCBFunc_t">evtCBFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*evtCBFunc_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;pi,&nbsp;unsigned&nbsp;event,&nbsp;uint32_t&nbsp;tick);<br></code><h3><a name="evtCBFuncEx_t">evtCBFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*evtCBFuncEx_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;pi,&nbsp;unsigned&nbsp;event,&nbsp;uint32_t&nbsp;tick,&nbsp;void&nbsp;*userdata);<br></code><h3><a name="f">f</a></h3>
A function.
<h3><a name="*file">*file</a></h3>
A full file path.  To be accessible the path must match an entry in
/opt/pigpio/access.
<h3><a name="*fpat">*fpat</a></h3>
A file path which may contain wildcards.  To be accessible the path
must match an entry in /opt/pigpio/access.
<h3><a name="frequency">frequency</a>: &gt;=0</h3>
The number of times a GPIO is swiched on and off per second.  This
can be set per GPIO and may be as little as 5Hz or as much as
40KHz.  The GPIO will be on for a proportion of the time as defined
by its dutycycle.
<h3><a name="gpio">gpio</a></h3>
A Broadcom numbered GPIO, in the range 0-53.
<br><br>There  are 54 General Purpose Input Outputs (GPIO) named GPIO0 through
GPIO53.
<br><br>They are split into two  banks.   Bank  1  consists  of  GPIO0  through
GPIO31.  Bank 2 consists of GPIO32 through GPIO53.
<br><br>All the GPIO which are safe for the user to read and write are in
bank 1.  Not all GPIO in bank 1 are safe though.  Type 1 boards
have 17  safe GPIO.  Type 2 boards have 21.  Type 3 boards have 26.
<br><br>See <a href="#get_hardware_revision">get_hardware_revision</a>.
<br><br>The user GPIO are marked with an X in the following table.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15<br>Type&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;25&nbsp;26&nbsp;27&nbsp;28&nbsp;29&nbsp;30&nbsp;31<br>Type&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-<br>Type&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-<br></code><h3><a name="gpioPulse_t">gpioPulse_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOn;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOff;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;usDelay;<br>}&nbsp;gpioPulse_t;<br></code><h3><a name="gpioThreadFunc_t">gpioThreadFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;*(gpioThreadFunc_t)&nbsp;(void&nbsp;*);<br></code><h3><a name="handle">handle</a>: &gt;=0</h3>
A number referencing an object opened by one of
<br><br><a href="#file_open">file_open</a><br>
<a href="#i2c_open">i2c_open</a><br>
<a href="#notify_open">notify_open</a><br>
<a href="#serial_open">serial_open</a><br>
<a href="#spi_open">spi_open</a>
<h3><a name="i2c_addr">i2c_addr</a>: 0-0x7F</h3>
The address of a device on the I2C bus.
<h3><a name="i2c_bus">i2c_bus</a>: &gt;=0</h3>
An I2C bus number.
<h3><a name="i2c_flags">i2c_flags</a>: 0</h3>
Flags which modify an I2C open command.  None are currently defined.
<h3><a name="i2c_reg">i2c_reg</a>: 0-255</h3>
A register of an I2C device.
<h3><a name="*inBuf">*inBuf</a></h3>
A buffer used to pass data to a function.
<h3><a name="inLen">inLen</a></h3>
The number of bytes of data in a buffer.
<h3><a name="int">int</a></h3>
A whole number, negative or positive.
<h3><a name="int32_t">int32_t</a></h3>
A 32-bit signed value.
<h3><a name="invert">invert</a></h3>
A flag used to set normal or inverted bit bang serial data level logic.
<h3><a name="level">level</a></h3>
The level of a GPIO.  Low or High.
<br><br><code>PI_OFF&nbsp;0<br>PI_ON&nbsp;1<br><br>PI_CLEAR&nbsp;0<br>PI_SET&nbsp;1<br><br>PI_LOW&nbsp;0<br>PI_HIGH&nbsp;1<br></code><br><br>There is one exception.  If a watchdog expires on a GPIO the level will be
reported as PI_TIMEOUT.  See <a href="#set_watchdog">set_watchdog</a>.
<br><br><code>PI_TIMEOUT&nbsp;2<br></code><h3><a name="MISO">MISO</a></h3>
The GPIO used for the MISO signal when bit banging SPI.
<h3><a name="mode">mode</a></h3>
1. The operational mode of a GPIO, normally INPUT or OUTPUT.
<br><br><code>PI_INPUT&nbsp;0<br>PI_OUTPUT&nbsp;1<br>PI_ALT0&nbsp;4<br>PI_ALT1&nbsp;5<br>PI_ALT2&nbsp;6<br>PI_ALT3&nbsp;7<br>PI_ALT4&nbsp;3<br>PI_ALT5&nbsp;2<br></code><br><br>2. The mode of waveform transmission.
<br><br><code>PI_WAVE_MODE_ONE_SHOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>PI_WAVE_MODE_REPEAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>PI_WAVE_MODE_ONE_SHOT_SYNC&nbsp;2<br>PI_WAVE_MODE_REPEAT_SYNC&nbsp;&nbsp;&nbsp;3<br></code><br><br>3. A file open mode.
<br><br><code>PI_FILE_READ&nbsp;&nbsp;1<br>PI_FILE_WRITE&nbsp;2<br>PI_FILE_RW&nbsp;&nbsp;&nbsp;&nbsp;3<br></code><br><br>The following values can be or'd into the mode.
<br><br><code>PI_FILE_APPEND&nbsp;4<br>PI_FILE_CREATE&nbsp;8<br>PI_FILE_TRUNC&nbsp;&nbsp;16<br></code><h3><a name="MOSI">MOSI</a></h3>
The GPIO used for the MOSI signal when bit banging SPI.
<h3><a name="numBytes">numBytes</a></h3>
The number of bytes used to store characters in a string.  Depending
on the number of bits per character there may be 1, 2, or 4 bytes
per character.
<h3><a name="numPar">numPar</a>: 0-10</h3>
The number of parameters passed to a script.
<h3><a name="numPulses">numPulses</a></h3>
The number of pulses to be added to a waveform.
<h3><a name="offset">offset</a></h3>
The associated data starts this number of microseconds from the start of
the waveform.
<h3><a name="*outBuf">*outBuf</a></h3>
A buffer used to return data from a function.
<h3><a name="outLen">outLen</a></h3>
The size in bytes of an output buffer.
<h3><a name="pad">pad</a>: 0-2</h3>
A set of GPIO which share common drivers.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><h3><a name="padStrength">padStrength</a>: 1-16</h3>
The mA which may be drawn from each GPIO whilst still guaranteeing the
high and low levels.
<h3><a name="*param">*param</a></h3>
An array of script parameters.
<h3><a name="percent">percent</a>: 0-100</h3>
The size of waveform as percentage of maximum available.
<h3><a name="pi">pi</a></h3>
An integer defining a connected Pi.  The value is returned by
<a href="#pigpio_start">pigpio_start</a> upon success.
<h3><a name="*portStr">*portStr</a></h3>
A string specifying the port address used by the Pi running
the pigpio daemon.  It may be NULL in which case "8888"
is used unless overridden by the PIGPIO_PORT environment
variable.
<h3><a name="*pth">*pth</a></h3>
A thread identifier, returned by <a href="#start_thread">start_thread</a>.
<h3><a name="pthread_t">pthread_t</a></h3>
A thread identifier.
<h3><a name="pud">pud</a>: 0-2</h3>
The setting of the pull up/down resistor for a GPIO, which may be off,
pull-up, or pull-down.
<code>PI_PUD_OFF&nbsp;0<br>PI_PUD_DOWN&nbsp;1<br>PI_PUD_UP&nbsp;2<br></code><h3><a name="pulseLen">pulseLen</a></h3>
1-100, the length of a trigger pulse in microseconds.
<h3><a name="*pulses">*pulses</a></h3>
An array of pulses to be added to a waveform.
<h3><a name="pulsewidth">pulsewidth</a>: 0, 500-2500</h3>
<code>PI_SERVO_OFF&nbsp;0<br>PI_MIN_SERVO_PULSEWIDTH&nbsp;500<br>PI_MAX_SERVO_PULSEWIDTH&nbsp;2500<br></code><h3><a name="PWMduty">PWMduty</a>: 0-1000000 (1M)</h3>
The hardware PWM dutycycle.
<br><br><code>#define&nbsp;PI_HW_PWM_RANGE&nbsp;1000000<br></code><h3><a name="PWMfreq">PWMfreq</a>: 1-125M (1-187.5M for the BCM2711)</h3>
The hardware PWM frequency.
<br><br><code>#define&nbsp;PI_HW_PWM_MIN_FREQ&nbsp;1<br>#define&nbsp;PI_HW_PWM_MAX_FREQ&nbsp;125000000<br>#define&nbsp;PI_HW_PWM_MAX_FREQ_2711&nbsp;187500000<br></code><h3><a name="range">range</a>: 25-40000</h3>
The permissible dutycycle values are 0-range.
<br><br><code>PI_MIN_DUTYCYCLE_RANGE&nbsp;25<br>PI_MAX_DUTYCYCLE_RANGE&nbsp;40000<br></code><h3><a name="*retBuf">*retBuf</a></h3>
A buffer to hold a number of bytes returned to a used customised function,
<h3><a name="retMax">retMax</a></h3>
The maximum number of bytes a user customised function should return.
<h3><a name="*rxBuf">*rxBuf</a></h3>
A pointer to a buffer to receive data.
<h3><a name="SCL">SCL</a></h3>
The user GPIO to use for the clock when bit banging I2C.
<h3><a name="SCLK">SCLK</a></h3>
The GPIO used for the SCLK signal when bit banging SPI.
<h3><a name="*script">*script</a></h3>
A pointer to the text of a script.
<h3><a name="script_id">script_id</a></h3>
An id of a stored script as returned by <a href="#store_script">store_script</a>.
<h3><a name="*scriptName">*scriptName</a></h3>
The name of a <a href="#shell_">shell_</a> script to be executed.  The script must be present in
/opt/pigpio/cgi and must have execute permission.
<h3><a name="*scriptString">*scriptString</a></h3>
The string to be passed to a <a href="#shell_">shell_</a> script to be executed.
<h3><a name="SDA">SDA</a></h3>
The user GPIO to use for data when bit banging I2C.
<h3><a name="seconds">seconds</a></h3>
The number of seconds.
<h3><a name="seekFrom">seekFrom</a></h3>
<code>PI_FROM_START&nbsp;&nbsp;&nbsp;0<br>PI_FROM_CURRENT&nbsp;1<br>PI_FROM_END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br></code><h3><a name="seekOffset">seekOffset</a></h3>
The number of bytes to move forward (positive) or backwards (negative)
from the seek position (start, current, or end of file).
<h3><a name="ser_flags">ser_flags</a></h3>
Flags which modify a serial open command.  None are currently defined.
<h3><a name="*ser_tty">*ser_tty</a></h3>
The name of a serial tty device, e.g. /dev/ttyAMA0, /dev/ttyUSB0, /dev/tty1.
<h3><a name="size_t">size_t</a></h3>
A standard type used to indicate the size of an object in bytes.
<h3><a name="spi_channel">spi_channel</a></h3>
A SPI channel, 0-2.
<h3><a name="spi_flags">spi_flags</a></h3>
See <a href="#spi_open">spi_open</a> and <a href="#bb_spi_open">bb_spi_open</a>.
<h3><a name="steady">steady</a>: 0-300000</h3>
The number of microseconds level changes must be stable for
before reporting the level changed (<a href="#set_glitch_filter">set_glitch_filter</a>) or triggering
the active part of a noise filter (<a href="#set_noise_filter">set_noise_filter</a>).
<h3><a name="stop_bits">stop_bits</a>: 2-8</h3>
The number of (half) stop bits to be used when adding serial data
to a waveform.
<br><br><code>#define&nbsp;PI_MIN_WAVE_HALFSTOPBITS&nbsp;2<br>#define&nbsp;PI_MAX_WAVE_HALFSTOPBITS&nbsp;8<br></code><h3><a name="*str">*str</a></h3>
 An array of characters.
<h3><a name="thread_func">thread_func</a></h3>
A function of type gpioThreadFunc_t used as the main function of a
thread.
<h3><a name="timeout">timeout</a></h3>
A GPIO watchdog timeout in milliseconds.
<br><br><code>PI_MIN_WDOG_TIMEOUT&nbsp;0<br>PI_MAX_WDOG_TIMEOUT&nbsp;60000<br></code><h3><a name="*txBuf">*txBuf</a></h3>
An array of bytes to transmit.
<h3><a name="uint32_t">uint32_t</a>: 0-0-4,294,967,295 (Hex 0x0-0xFFFFFFFF)</h3>
A 32-bit unsigned value.
<h3><a name="unsigned">unsigned</a></h3>
A whole number &gt;= 0.
<h3><a name="user_gpio">user_gpio</a></h3>
0-31, a Broadcom numbered GPIO.
<br><br>See <a href="#gpio">gpio</a>.
<h3><a name="*userdata">*userdata</a></h3>
A pointer to arbitrary user data.  This may be used to identify the instance.
<br><br>You must ensure that the pointer is in scope at the time it is processed.  If
it is a pointer to a global this is automatic.  Do not pass the address of a
local variable.  If you want to pass a transient object then use the
following technique.
<br><br>In the calling function:
<br><br><code>user_type&nbsp;*userdata;<br><br>user_type&nbsp;my_userdata;<br><br>userdata&nbsp;=&nbsp;malloc(sizeof(user_type));<br><br>*userdata&nbsp;=&nbsp;my_userdata;<br></code><br><br>In the receiving function:
<br><br><code>user_type&nbsp;my_userdata&nbsp;=&nbsp;*(user_type*)userdata;<br><br>free(userdata);<br></code><h3><a name="void">void</a></h3>
Denoting no parameter is required
<h3><a name="wave_add_*">wave_add_*</a></h3>
One of
<br><br><a href="#wave_add_new">wave_add_new</a><br>
<a href="#wave_add_generic">wave_add_generic</a><br>
<a href="#wave_add_serial">wave_add_serial</a>
<h3><a name="wave_id">wave_id</a></h3>
A number representing a waveform created by <a href="#wave_create">wave_create</a>.
<h3><a name="wave_send_*">wave_send_*</a></h3>
One of
<br><br><a href="#wave_send_once">wave_send_once</a><br>
<a href="#wave_send_repeat">wave_send_repeat</a>
<h3><a name="wVal">wVal</a>: 0-65535 (Hex 0x0-0xFFFF, Octal 0-0177777)</h3>
A 16-bit word value.
<h2>pigpiod_if2 Error Codes</h2><code><br>typedef&nbsp;enum<br>{<br>&nbsp;&nbsp;&nbsp;pigif_bad_send&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2000,<br>&nbsp;&nbsp;&nbsp;pigif_bad_recv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2001,<br>&nbsp;&nbsp;&nbsp;pigif_bad_getaddrinfo&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2002,<br>&nbsp;&nbsp;&nbsp;pigif_bad_connect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2003,<br>&nbsp;&nbsp;&nbsp;pigif_bad_socket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2004,<br>&nbsp;&nbsp;&nbsp;pigif_bad_noib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2005,<br>&nbsp;&nbsp;&nbsp;pigif_duplicate_callback&nbsp;=&nbsp;-2006,<br>&nbsp;&nbsp;&nbsp;pigif_bad_malloc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2007,<br>&nbsp;&nbsp;&nbsp;pigif_bad_callback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2008,<br>&nbsp;&nbsp;&nbsp;pigif_notify_failed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2009,<br>&nbsp;&nbsp;&nbsp;pigif_callback_not_found&nbsp;=&nbsp;-2010,<br>&nbsp;&nbsp;&nbsp;pigif_unconnected_pi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2011,<br>&nbsp;&nbsp;&nbsp;pigif_too_many_pis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-2012,<br>}&nbsp;pigifError_t;<br><br></code></td>
</table>
<div style="vertical-align: center; text-align: center; background-color:#98bf21; font-size:0.8em; height:30px"><a class="l2" href="index.html">[pigpio]</a>
<a class="l2" href="cif.html">[pigpio C I/F]</a>
<a class="l2" href="pigpiod.html">[pigpiod]</a>
<a class="l2" href="pdif2.html">[pigpiod C I/F]</a>
<a class="l2" href="python.html">[Python]</a>
<a class="l2" href="pigs.html">[pigs]</a>
<a class="l2" href="piscope.html">[piscope]</a>
<a class="l2" href="misc.html">[Misc]</a>
<a class="l2" href="examples.html">[Examples]</a>
<a class="l2" href="download.html">[Download]</a>
<a class="l2" href="faq.html">[FAQ]</a>
<a class="l2" href="sitemap.html">[Site Map]</a>
</div>
<table><tr>
<td style="width: 200px"><div style="text-align: left;"><small>&copy; 2012-2020</small></div></td>
<td style="width: 350px"><div style="text-align: center;">e-mail: pigpio @ abyz.me.uk</div></td>
<td style="width: 200px"><div style="text-align: right;"><small>Updated: 30/04/2020</small></div></td>
</tr></table>
</td>
</table>
</body>
</html>
