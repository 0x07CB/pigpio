
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
   <meta name="description" content="Raspberry Pi Reg. C GPIO library and Python GPIO module and shell command utilities to control the GPIO, including SPI, I2C, and serial links." />
   <meta name="keywords" content="raspberry, pi, C, Python, GPIO, library, shell, command, utilities, module, SPI, I2C, serial" />
   <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
   <title>pigpio library</title>
   <link rel="stylesheet" type="text/css" href="scripts/index.css">
   <link rel="icon" href="favicon.ico" type="image/x-icon">
   <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
</head>
<body>

<table style="padding:0px; border:0px; margin:0px; width:780px; background-color:#e0e0e0;">
<td style="background:#EAF2E6 url('images/sidebar.gif') repeat-y; width:35px; height:100%"></td>
<td>
<table>
<div style="background:url('images/topbar.gif') repeat-x; height: 70px; font-size:1.5em; vertical-align: top;"><a href="index.html"><img src="images/pigpio-logo.gif" border="0" /></a>pigpio library</div>
</table>
<table><div>
<td><img src="images/pins.jpg" width="250"></td>
<td><img src="images/meter.jpg" width="250"></td>
<td><img src="images/keypad.jpg" width="250"></td>
</div></table>
<table>
<td style="vertical-align: top; background-color: #98bf21;"><a class="l1" href="index.html">pigpio</a>
<a class="l1" href="cif.html">pigpio C I/F</a>
<a class="l1" href="pigpiod.html">pigpiod</a>
<a class="l1" href="pdif2.html">pigpiod C I/F</a>
<a class="l1" href="python.html">Python</a>
<a class="l1" href="pigs.html">pigs</a>
<a class="l1" href="piscope.html">piscope</a>
<a class="l1" href="misc.html">Misc</a>
<a class="l1" href="examples.html">Examples</a>
<a class="l1" href="download.html">Download</a>
<a class="l1" href="faq.html">FAQ</a>
<a class="l1" href="sitemap.html">Site Map</a>
</td>
<td><center><h2>pigs</h2></center><h2><a name="Introduction">Introduction</a></h2>
The socket and pipe interfaces allow control of the Pi's GPIO by
passing messages to the running pigpio library.
<br><br>The normal way to start the pigpio library would be as a daemon during boot.
<br><br><code>sudo&nbsp;pigpiod<br></code><h3>Features</h3>o hardware timed PWM on any of GPIO 0-31
<br><br>o hardware timed servo pulses on any of GPIO 0-31
<br><br>o reading/writing all of the GPIO in a bank as one operation
<br><br>o individually setting GPIO modes, reading and writing
<br><br>o notifications when any of GPIO 0-31 change state
<br><br>o the construction of output waveforms with microsecond timing
<br><br>o I2C, SPI, and serial link wrappers
<br><br>o creating and running scripts on the pigpio daemon
<h3>GPIO</h3>ALL GPIO are identified by their Broadcom number.
<h3>Usage</h3>pigs is a program and internally uses the socket interface to pigpio
whereas /dev/pigpio uses the pipe interface.
<br><br>pigs and the pipe interface share the same commands and are invoked in
a similar fashion from the command line.
<br><br>The pigpio library must be running, either by running a program linked
with the library or starting the pigpio daemon (sudo pigpiod).
<br><br>pigs {command}+
<br><br>echo "{command}+" &gt;/dev/pigpio
<br><br>pigs will show the result of the command on screen.
<br><br>The pigs process returns an exit status (which can be displayed with
the command echo $?).
<br><br><code>PIGS_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>PIGS_CONNECT_ERR&nbsp;255<br>PIGS_OPTION_ERR&nbsp;&nbsp;254<br>PIGS_SCRIPT_ERR&nbsp;&nbsp;253<br><br></code><br><br>The results of /dev/pigpio commands need to be read from /dev/pigout,
e.g. cat /dev/pigout (try cat /dev/pigout& so that all subsequent
results are shown on screen).
<br><br>In both cases if an error was detected a message will have been written
to /dev/pigerr (try cat /dev/pigerr&).  This is likely to be more
informative than the message returned by pigs or the error code
returned by the pipe interface.
<br><br>Several commands may be entered on a line.  If present PROC and PARSE must
be the last command on a line.
<br><br>E.g.
<br><br><code>pigs&nbsp;w&nbsp;22&nbsp;1&nbsp;mils&nbsp;1000&nbsp;w&nbsp;22&nbsp;0<br></code><br><br>is equivalent to
<br><br><code>pigs&nbsp;w&nbsp;22&nbsp;1<br>pigs&nbsp;mils&nbsp;1000<br>pigs&nbsp;w&nbsp;22&nbsp;0<br></code><br><br>and
<br><br><code>echo&nbsp;"m&nbsp;4&nbsp;w&nbsp;w&nbsp;4&nbsp;0&nbsp;mils&nbsp;250&nbsp;m&nbsp;4&nbsp;r&nbsp;r&nbsp;4"&nbsp;&gt;/dev/pigpio<br></code><br><br>is equivalent to
<br><br><code>echo&nbsp;"m&nbsp;4&nbsp;w"&nbsp;&nbsp;&nbsp;&nbsp;&gt;/dev/pigpio<br>echo&nbsp;"w&nbsp;4&nbsp;0"&nbsp;&nbsp;&nbsp;&nbsp;&gt;/dev/pigpio<br>echo&nbsp;"mils&nbsp;250"&nbsp;&gt;/dev/pigpio<br>echo&nbsp;"m&nbsp;4&nbsp;r"&nbsp;&nbsp;&nbsp;&nbsp;&gt;/dev/pigpio<br>echo&nbsp;"r&nbsp;4"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;/dev/pigpio<br></code><h3>Notes</h3>The examples from now on will show the pigs interface but the same
commands will also work on the pipe interface.
<br><br>pigs does not show the status of successful commands unless the
command itself returns data.  The status (0) will be returned to
pigs but will be discarded.
<br><br>The status/data of each command sent to the pipe interface should
be read from /dev/pigout.
<br><br>When a command takes a number as a parameter it may be entered as hex
(precede by 0x), octal (precede by 0), or decimal.
<br><br>E.g. 23 is 23 decimal, 0x100 is 256 decimal, 070 is 56 decimal.
<br><br>Some commands can return a variable number of data bytes.  By
default this data is displayed as decimal.  The pigs -a option
can be used to force the display as ASCII and the pigs -x
option can be used to force the display as hex.
<br><br>E.g. assuming the transmitted serial data is the letters ABCDEONM
<br><br><code>$&nbsp;pigs&nbsp;slr&nbsp;4&nbsp;100<br>8&nbsp;65&nbsp;66&nbsp;67&nbsp;68&nbsp;69&nbsp;79&nbsp;78&nbsp;77<br><br>$&nbsp;pigs&nbsp;-a&nbsp;slr&nbsp;4&nbsp;100<br>8&nbsp;ABCDEONM<br><br>$&nbsp;pigs&nbsp;-x&nbsp;slr&nbsp;4&nbsp;100<br>8&nbsp;41&nbsp;42&nbsp;43&nbsp;44&nbsp;45&nbsp;4f&nbsp;4e&nbsp;4d<br></code><h2><a name="Overview">Overview</a></h2>
<table border="0" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td></td><td></td></tr><tr><td>BASIC
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#M/MODES">M/MODES</a> <a href="#g">g</a> <a href="#m">m</a></td><td>Set GPIO mode </td><td><small><a href="cif.html#gpioSetMode">gpioSetMode</a></small></td></tr><tr><td><a href="#MG/MODEG">MG/MODEG</a> <a href="#g">g</a></td><td>Get GPIO mode </td><td><small><a href="cif.html#gpioGetMode">gpioGetMode</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#PUD">PUD</a> <a href="#g">g</a> <a href="#p">p</a></td><td>Set GPIO pull up/down </td><td><small><a href="cif.html#gpioSetPullUpDown">gpioSetPullUpDown</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#R/READ">R/READ</a> <a href="#g">g</a></td><td>Read GPIO level  </td><td><small><a href="cif.html#gpioRead">gpioRead</a></small></td></tr><tr><td><a href="#W/WRITE">W/WRITE</a> <a href="#g">g</a> <a href="#L">L</a></td><td>Write GPIO level </td><td><small><a href="cif.html#gpioWrite">gpioWrite</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>PWM (overrides servo commands on same GPIO)
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#P/PWM">P/PWM</a> <a href="#u">u</a> <a href="#v">v</a></td><td>Set GPIO PWM value      </td><td><small><a href="cif.html#gpioPWM">gpioPWM</a></small></td></tr><tr><td><a href="#PFS">PFS</a> <a href="#u">u</a> <a href="#v">v</a></td><td>Set GPIO PWM frequency  </td><td><small><a href="cif.html#gpioSetPWMfrequency">gpioSetPWMfrequency</a></small></td></tr><tr><td><a href="#PRS">PRS</a> <a href="#u">u</a> <a href="#v">v</a></td><td>Set GPIO PWM range      </td><td><small><a href="cif.html#gpioSetPWMrange">gpioSetPWMrange</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#GDC">GDC</a> <a href="#u">u</a></td><td>Get GPIO PWM dutycycle  </td><td><small><a href="cif.html#gpioGetPWMdutycycle">gpioGetPWMdutycycle</a></small></td></tr><tr><td><a href="#PFG">PFG</a> <a href="#u">u</a></td><td>Get GPIO PWM frequency  </td><td><small><a href="cif.html#gpioGetPWMfrequency">gpioGetPWMfrequency</a></small></td></tr><tr><td><a href="#PRG">PRG</a> <a href="#u">u</a></td><td>Get GPIO PWM range      </td><td><small><a href="cif.html#gpioGetPWMrange">gpioGetPWMrange</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#PRRG">PRRG</a> <a href="#u">u</a></td><td>Get GPIO PWM real range </td><td><small><a href="cif.html#gpioGetPWMrealRange">gpioGetPWMrealRange</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Servo (overrides PWM commands on same GPIO)
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#S/SERVO">S/SERVO</a> <a href="#u">u</a> <a href="#v">v</a></td><td>Set GPIO servo pulsewidth </td><td><small><a href="cif.html#gpioServo">gpioServo</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#GPW">GPW</a> <a href="#u">u</a></td><td>Get GPIO servo pulsewidth </td><td><small><a href="cif.html#gpioGetServoPulsewidth">gpioGetServoPulsewidth</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>INTERMEDIATE
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#TRIG">TRIG</a> <a href="#u">u</a> <a href="#pl">pl</a> <a href="#L">L</a></td><td>Send a trigger pulse </td><td><small><a href="cif.html#gpioTrigger">gpioTrigger</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WDOG">WDOG</a> <a href="#u">u</a> <a href="#v">v</a></td><td>Set GPIO watchdog    </td><td><small><a href="cif.html#gpioSetWatchdog">gpioSetWatchdog</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BR1">BR1</a></td><td>Read bank 1 GPIO               </td><td><small><a href="cif.html#gpioRead_Bits_0_31">gpioRead_Bits_0_31</a></small></td></tr><tr><td><a href="#BR2">BR2</a></td><td>Read bank 2 GPIO               </td><td><small><a href="cif.html#gpioRead_Bits_32_53">gpioRead_Bits_32_53</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BC1">BC1</a> <a href="#bits">bits</a></td><td>Clear specified GPIO in bank 1 </td><td><small><a href="cif.html#gpioWrite_Bits_0_31_Clear">gpioWrite_Bits_0_31_Clear</a></small></td></tr><tr><td><a href="#BC2">BC2</a> <a href="#bits">bits</a></td><td>Clear specified GPIO in bank 2 </td><td><small><a href="cif.html#gpioWrite_Bits_32_53_Clear">gpioWrite_Bits_32_53_Clear</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BS1">BS1</a> <a href="#bits">bits</a></td><td>Set specified GPIO in bank 1   </td><td><small><a href="cif.html#gpioWrite_Bits_0_31_Set">gpioWrite_Bits_0_31_Set</a></small></td></tr><tr><td><a href="#BS2">BS2</a> <a href="#bits">bits</a></td><td>Set specified GPIO in bank 2   </td><td><small><a href="cif.html#gpioWrite_Bits_32_53_Set">gpioWrite_Bits_32_53_Set</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>ADVANCED
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#NO">NO</a></td><td>Request a notification </td><td><small><a href="cif.html#gpioNotifyOpen">gpioNotifyOpen</a></small></td></tr><tr><td><a href="#NC">NC</a> <a href="#h">h</a></td><td>Close notification     </td><td><small><a href="cif.html#gpioNotifyClose">gpioNotifyClose</a></small></td></tr><tr><td><a href="#NB">NB</a> <a href="#h">h</a> <a href="#bits">bits</a></td><td>Start notification     </td><td><small><a href="cif.html#gpioNotifyBegin">gpioNotifyBegin</a></small></td></tr><tr><td><a href="#NP">NP</a> <a href="#h">h</a></td><td>Pause notification     </td><td><small><a href="cif.html#gpioNotifyPause">gpioNotifyPause</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#HC">HC</a> <a href="#g">g</a> <a href="#cf">cf</a></td><td>Set hardware clock frequency </td><td><small><a href="cif.html#gpioHardwareClock">gpioHardwareClock</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#HP">HP</a> <a href="#g">g</a> <a href="#pf">pf</a> <a href="#pdc">pdc</a></td><td>Set hardware PWM frequency and dutycycle </td><td><small><a href="cif.html#gpioHardwarePWM">gpioHardwarePWM</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#FG">FG</a> <a href="#u">u</a> <a href="#stdy">stdy</a></td><td>Set a glitch filter on a GPIO  </td><td><small><a href="cif.html#gpioGlitchFilter">gpioGlitchFilter</a></small></td></tr><tr><td><a href="#FN">FN</a> <a href="#u">u</a> <a href="#stdy">stdy</a> <a href="#actv">actv</a></td><td>Set a noise filter on a GPIO   </td><td><small><a href="cif.html#gpioNoiseFilter">gpioNoiseFilter</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#PADS">PADS</a> <a href="#pad">pad</a> <a href="#padma">padma</a></td><td>Set pad drive strength </td><td><small><a href="cif.html#gpioSetPad">gpioSetPad</a></small></td></tr><tr><td><a href="#PADG">PADG</a> <a href="#pad">pad</a></td><td>Get pad drive strength </td><td><small><a href="cif.html#gpioGetPad">gpioGetPad</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SHELL">SHELL</a> <a href="#name">name</a> <a href="#str">str</a></td><td>Execute a shell command </td><td><small><a href="cif.html#shell">shell</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Custom
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#CF1">CF1</a> <a href="#uvs">uvs</a></td><td>Custom function 1 </td><td><small><a href="cif.html#gpioCustom1">gpioCustom1</a></small></td></tr><tr><td><a href="#CF2">CF2</a> <a href="#uvs">uvs</a></td><td>Custom function 2 </td><td><small><a href="cif.html#gpioCustom1">gpioCustom1</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Events
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#EVM">EVM</a> <a href="#h">h</a> <a href="#bits">bits</a></td><td>Set events to monitor </td><td><small><a href="cif.html#eventMonitor">eventMonitor</a></small></td></tr><tr><td><a href="#EVT">EVT</a> <a href="#event">event</a></td><td>Trigger event         </td><td><small><a href="cif.html#eventTrigger">eventTrigger</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>Scripts
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#PROC">PROC</a> <a href="#t">t</a></td><td>Store script                     </td><td><small><a href="cif.html#gpioStoreScript">gpioStoreScript</a></small></td></tr><tr><td><a href="#PROCR">PROCR</a> <a href="#sid">sid</a> <a href="#pars">pars</a></td><td>Run script                       </td><td><small><a href="cif.html#gpioRunScript">gpioRunScript</a></small></td></tr><tr><td><a href="#PROCU">PROCU</a> <a href="#sid">sid</a> <a href="#pars">pars</a></td><td>Set script parameters            </td><td><small><a href="cif.html#gpioUpdateScript">gpioUpdateScript</a></small></td></tr><tr><td><a href="#PROCP">PROCP</a> <a href="#sid">sid</a></td><td>Get script status and parameters </td><td><small><a href="cif.html#gpioScriptStatus">gpioScriptStatus</a></small></td></tr><tr><td><a href="#PROCS">PROCS</a> <a href="#sid">sid</a></td><td>Stop script                      </td><td><small><a href="cif.html#gpioStopScript">gpioStopScript</a></small></td></tr><tr><td><a href="#PROCD">PROCD</a> <a href="#sid">sid</a></td><td>Delete script                    </td><td><small><a href="cif.html#gpioDeleteScript">gpioDeleteScript</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#PARSE">PARSE</a> <a href="#t">t</a></td><td>Validate script                  </td><td><small><a href="cif.html#gpioParseScript">gpioParseScript</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>I2C
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CO">I2CO</a> <a href="#ib">ib</a> <a href="#id">id</a> <a href="#if">if</a></td><td>Open I2C bus and device with flags </td><td><small><a href="cif.html#i2cOpen">i2cOpen</a></small></td></tr><tr><td><a href="#I2CC">I2CC</a> <a href="#h">h</a></td><td>Close I2C handle                   </td><td><small><a href="cif.html#i2cClose">i2cClose</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CWQ">I2CWQ</a> <a href="#h">h</a> <a href="#bit">bit</a></td><td>smb Write Quick: write bit </td><td><small><a href="cif.html#i2cWriteQuick">i2cWriteQuick</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CRS">I2CRS</a> <a href="#h">h</a></td><td>smb Read Byte: read byte   </td><td><small><a href="cif.html#i2cReadByte">i2cReadByte</a></small></td></tr><tr><td><a href="#I2CWS">I2CWS</a> <a href="#h">h</a> <a href="#bv">bv</a></td><td>smb Write Byte: write byte </td><td><small><a href="cif.html#i2cWriteByte">i2cWriteByte</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CRB">I2CRB</a> <a href="#h">h</a> <a href="#r">r</a></td><td>smb Read Byte Data: read byte from register </td><td><small><a href="cif.html#i2cReadByteData">i2cReadByteData</a></small></td></tr><tr><td><a href="#I2CWB">I2CWB</a> <a href="#h">h</a> <a href="#r">r</a> <a href="#bv">bv</a></td><td>smb Write Byte Data: write byte to register </td><td><small><a href="cif.html#i2cWriteByteData">i2cWriteByteData</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CRW">I2CRW</a> <a href="#h">h</a> <a href="#r">r</a></td><td>smb Read Word Data: read word from register </td><td><small><a href="cif.html#i2cReadWordData">i2cReadWordData</a></small></td></tr><tr><td><a href="#I2CWW">I2CWW</a> <a href="#h">h</a> <a href="#r">r</a> <a href="#wv">wv</a></td><td>smb Write Word Data: write word to register </td><td><small><a href="cif.html#i2cWriteWordData">i2cWriteWordData</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CRK">I2CRK</a> <a href="#h">h</a> <a href="#r">r</a></td><td>smb Read Block Data: read data from register </td><td><small><a href="cif.html#i2cReadBlockData">i2cReadBlockData</a></small></td></tr><tr><td><a href="#I2CWK">I2CWK</a> <a href="#h">h</a> <a href="#r">r</a> <a href="#bvs">bvs</a></td><td>smb Write Block Data: write data to register </td><td><small><a href="cif.html#i2cWriteBlockData">i2cWriteBlockData</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CWI">I2CWI</a> <a href="#h">h</a> <a href="#r">r</a> <a href="#bvs">bvs</a></td><td>smb Write I2C Block Data                          </td><td><small><a href="cif.html#i2cWriteI2CBlockData">i2cWriteI2CBlockData</a></small></td></tr><tr><td><a href="#I2CRI">I2CRI</a> <a href="#h">h</a> <a href="#r">r</a> <a href="#num">num</a></td><td>smb Read I2C Block Data: read bytes from register </td><td><small><a href="cif.html#i2cReadI2CBlockData">i2cReadI2CBlockData</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CRD">I2CRD</a> <a href="#h">h</a> <a href="#num">num</a></td><td>i2c Read device  </td><td><small><a href="cif.html#i2cReadDevice">i2cReadDevice</a></small></td></tr><tr><td><a href="#I2CWD">I2CWD</a> <a href="#h">h</a> <a href="#bvs">bvs</a></td><td>i2c Write device </td><td><small><a href="cif.html#i2cWriteDevice">i2cWriteDevice</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CPC">I2CPC</a> <a href="#h">h</a> <a href="#r">r</a> <a href="#wv">wv</a></td><td>smb Process Call: exchange register with word             </td><td><small><a href="cif.html#i2cProcessCall">i2cProcessCall</a></small></td></tr><tr><td><a href="#I2CPK">I2CPK</a> <a href="#h">h</a> <a href="#r">r</a> <a href="#bvs">bvs</a></td><td>smb Block Process Call: exchange data bytes with register </td><td><small><a href="cif.html#i2cBlockProcessCall">i2cBlockProcessCall</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#I2CZ">I2CZ</a> <a href="#h">h</a> <a href="#bvs">bvs</a></td><td>Performs multiple I2C transactions </td><td><small><a href="cif.html#i2cZip">i2cZip</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>I2C BIT BANG
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BI2CO">BI2CO</a> <a href="#sda">sda</a> <a href="#scl">scl</a> <a href="#b">b</a></td><td>Open bit bang I2C  </td><td><small><a href="cif.html#bbI2COpen">bbI2COpen</a></small></td></tr><tr><td><a href="#BI2CC">BI2CC</a> <a href="#sda">sda</a></td><td>Close bit bang I2C </td><td><small><a href="cif.html#bbI2CClose">bbI2CClose</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BI2CZ">BI2CZ</a> <a href="#sda">sda</a> <a href="#bvs">bvs</a></td><td>I2C bit bang multiple transactions </td><td><small><a href="cif.html#bbI2CZip">bbI2CZip</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>I2C/SPI SLAVE
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BSCX">BSCX</a> <a href="#bctl">bctl</a> <a href="#bvs">bvs</a></td><td>BSC I2C/SPI transfer </td><td><small><a href="cif.html#bscXfer">bscXfer</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>SERIAL
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SERO">SERO</a> <a href="#dev">dev</a> <a href="#b">b</a> <a href="#sef">sef</a></td><td>Open serial device dev at baud b with flags </td><td><small><a href="cif.html#serOpen">serOpen</a></small></td></tr><tr><td><a href="#SERC">SERC</a> <a href="#h">h</a></td><td>Close serial handle                         </td><td><small><a href="cif.html#serClose">serClose</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SERRB">SERRB</a></td><td>Read byte from serial handle  </td><td><small><a href="cif.html#serReadByte">serReadByte</a></small></td></tr><tr><td><a href="#SERWB">SERWB</a> <a href="#h">h</a> <a href="#bv">bv</a></td><td>Write byte to serial handle   </td><td><small><a href="cif.html#serWriteByte">serWriteByte</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SERR">SERR</a> <a href="#h">h</a> <a href="#num">num</a></td><td>Read bytes from serial handle </td><td><small><a href="cif.html#serRead">serRead</a></small></td></tr><tr><td><a href="#SERW">SERW</a> <a href="#h">h</a> <a href="#bvs">bvs</a></td><td>Write bytes to serial handle  </td><td><small><a href="cif.html#serWrite">serWrite</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SERDA">SERDA</a> <a href="#h">h</a></td><td>Check for serial data ready to read </td><td><small><a href="cif.html#serDataAvailable">serDataAvailable</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>SERIAL BIT BANG (read only)
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SLRO">SLRO</a> <a href="#u">u</a> <a href="#b">b</a> <a href="#db">db</a></td><td>Open GPIO for bit bang serial data     </td><td><small><a href="cif.html#gpioSerialReadOpen">gpioSerialReadOpen</a></small></td></tr><tr><td><a href="#SLRC">SLRC</a> <a href="#u">u</a></td><td>Close GPIO for bit bang serial data    </td><td><small><a href="cif.html#gpioSerialReadClose">gpioSerialReadClose</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SLRI">SLRI</a> <a href="#u">u</a> <a href="#v">v</a></td><td>Sets bit bang serial data logic levels </td><td><small><a href="cif.html#gpioSerialReadInvert">gpioSerialReadInvert</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SLR">SLR</a> <a href="#u">u</a> <a href="#num">num</a></td><td>Read bit bang serial data from GPIO    </td><td><small><a href="cif.html#gpioSerialRead">gpioSerialRead</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>SPI
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SPIO">SPIO</a> <a href="#c">c</a> <a href="#b">b</a> <a href="#spf">spf</a></td><td>SPI open channel at baud b with flags </td><td><small><a href="cif.html#spiOpen">spiOpen</a></small></td></tr><tr><td><a href="#SPIC">SPIC</a> <a href="#h">h</a></td><td>SPI close handle                    </td><td><small><a href="cif.html#spiClose">spiClose</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#SPIR">SPIR</a> <a href="#h">h</a> <a href="#num">num</a></td><td>SPI read bytes from handle          </td><td><small><a href="cif.html#spiRead">spiRead</a></small></td></tr><tr><td><a href="#SPIW">SPIW</a> <a href="#h">h</a> <a href="#bvs">bvs</a></td><td>SPI write bytes to handle           </td><td><small><a href="cif.html#spiWrite">spiWrite</a></small></td></tr><tr><td><a href="#SPIX">SPIX</a> <a href="#h">h</a> <a href="#bvs">bvs</a></td><td>SPI transfer bytes to handle        </td><td><small><a href="cif.html#spiXfer">spiXfer</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>SPI BIT BANG
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BSPIO">BSPIO</a> <a href="#cs">cs</a> <a href="#miso">miso</a> <a href="#mosi">mosi</a> <a href="#sclk">sclk</a> <a href="#b">b</a> <a href="#spf">spf</a></td><td>Open bit bang SPI      </td><td><small><a href="cif.html#bbSPIOpen">bbSPIOpen</a></small></td></tr><tr><td><a href="#BSPIC">BSPIC</a> <a href="#cs">cs</a></td><td>Close bit bang SPI    </td><td><small><a href="cif.html#bbSPIClose">bbSPIClose</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#BSPIX">BSPIX</a> <a href="#cs">cs</a> <a href="#bvs">bvs</a></td><td>SPI bit bang transfer </td><td><small><a href="cif.html#bbSPIXfer">bbSPIXfer</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>FILES
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#FO">FO</a> <a href="#file">file</a> <a href="#mode">mode</a></td><td>Open a file in mode            </td><td><small><a href="cif.html#fileOpen">fileOpen</a></small></td></tr><tr><td><a href="#FC">FC</a> <a href="#h">h</a></td><td>Close file handle              </td><td><small><a href="cif.html#fileClose">fileClose</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#FR">FR</a> <a href="#h">h</a> <a href="#num">num</a></td><td>Read bytes from file handle    </td><td><small><a href="cif.html#fileRead">fileRead</a></small></td></tr><tr><td><a href="#FW">FW</a> <a href="#h">h</a> <a href="#bvs">bvs</a></td><td>Write bytes to file handle     </td><td><small><a href="cif.html#fileWrite">fileWrite</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#FS">FS</a> <a href="#h">h</a> <a href="#num">num</a> <a href="#from">from</a></td><td>Seek to file handle position   </td><td><small><a href="cif.html#fileSeek">fileSeek</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#FL">FL</a> <a href="#pat">pat</a> <a href="#num">num</a></td><td>List files which match pattern </td><td><small><a href="cif.html#fileList">fileList</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>WAVES
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVCLR">WVCLR</a></td><td>Clear all waveforms </td><td><small><a href="cif.html#gpioWaveClear">gpioWaveClear</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVNEW">WVNEW</a></td><td>Initialise a new waveform    </td><td><small><a href="cif.html#gpioWaveAddNew">gpioWaveAddNew</a></small></td></tr><tr><td><a href="#WVAG">WVAG</a> <a href="#trips">trips</a></td><td>Add generic pulses to waveform </td><td><small><a href="cif.html#gpioWaveAddGeneric">gpioWaveAddGeneric</a></small></td></tr><tr><td><a href="#WVAS">WVAS</a> <a href="#u">u</a> <a href="#b">b</a> <a href="#db">db</a> <a href="#sb">sb</a> <a href="#o">o</a> <a href="#bvs">bvs</a></td><td>Add serial data to waveform    </td><td><small><a href="cif.html#gpioWaveAddSerial">gpioWaveAddSerial</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVCRE">WVCRE</a></td><td>Create a waveform   </td><td><small><a href="cif.html#gpioWaveCreate">gpioWaveCreate</a></small></td></tr><tr><td><a href="#WVCAP">WVCAP</a></td><td>Create a waveform of fixed size  </td><td><small><a href="cif.html#gpioWaveCreatePad">gpioWaveCreatePad</a></small></td></tr><tr><td><a href="#WVDEL">WVDEL</a> <a href="#wid">wid</a></td><td>Delete selected waveform </td><td><small><a href="cif.html#gpioWaveDelete">gpioWaveDelete</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVTX">WVTX</a> <a href="#wid">wid</a></td><td>Transmits waveform once       </td><td><small><a href="cif.html#gpioWaveTxSend">gpioWaveTxSend</a></small></td></tr><tr><td><a href="#WVTXM">WVTXM</a> <a href="#wid">wid</a> <a href="#wmde">wmde</a></td><td>Transmits waveform using mode </td><td><small><a href="cif.html#gpioWaveTxSend">gpioWaveTxSend</a></small></td></tr><tr><td><a href="#WVTXR">WVTXR</a> <a href="#wid">wid</a></td><td>Transmits waveform repeatedly </td><td><small><a href="cif.html#gpioWaveTxSend">gpioWaveTxSend</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVCHA">WVCHA</a> <a href="#bvs">bvs</a></td><td>Transmits a chain of waveforms </td><td><small><a href="cif.html#gpioWaveChain">gpioWaveChain</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVTAT">WVTAT</a></td><td>Returns the current transmitting waveform </td><td><small><a href="cif.html#gpioWaveTxAt">gpioWaveTxAt</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVBSY">WVBSY</a></td><td>Check if waveform is being transmitted </td><td><small><a href="cif.html#gpioWaveTxBusy">gpioWaveTxBusy</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVHLT">WVHLT</a></td><td>Stop waveform </td><td><small><a href="cif.html#gpioWaveTxStop">gpioWaveTxStop</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#WVSC">WVSC</a> <a href="#ws">ws</a></td><td>Get waveform DMA CB stats    </td><td><small><a href="cif.html#gpioWaveGetCbs">gpioWaveGetCbs</a></small></td></tr><tr><td><a href="#WVSM">WVSM</a> <a href="#ws">ws</a></td><td>Get waveform time stats      </td><td><small><a href="cif.html#gpioWaveGetMicros">gpioWaveGetMicros</a></small></td></tr><tr><td><a href="#WVSP">WVSP</a> <a href="#ws">ws</a></td><td>Get waveform pulse stats     </td><td><small><a href="cif.html#gpioWaveGetPulses">gpioWaveGetPulses</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>UTILITIES
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#H/HELP">H/HELP</a></td><td>Display command help        </td><td><small><a href="cif.html#"></a></small></td></tr><tr><td><a href="#HWVER">HWVER</a></td><td>Get hardware version        </td><td><small><a href="cif.html#gpioHardwareRevision">gpioHardwareRevision</a></small></td></tr><tr><td><a href="#MICS">MICS</a> <a href="#v">v</a></td><td>Microseconds delay          </td><td><small><a href="cif.html#gpioDelay">gpioDelay</a></small></td></tr><tr><td><a href="#MILS">MILS</a> <a href="#v">v</a></td><td>Milliseconds delay          </td><td><small><a href="cif.html#gpioDelay">gpioDelay</a></small></td></tr><tr><td><a href="#PIGPV">PIGPV</a></td><td>Get pigpio library version  </td><td><small><a href="cif.html#gpioVersion">gpioVersion</a></small></td></tr><tr><td><a href="#T/TICK">T/TICK</a></td><td>Get current tick            </td><td><small><a href="cif.html#gpioTick">gpioTick</a></small></td></tr><tr><td></td><td></td><td></td></tr><tr><td>CONFIGURATION
</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="#CGI">CGI</a></td><td>Configuration get internals </td><td><small><a href="cif.html#gpioCfgGetInternals">gpioCfgGetInternals</a></small></td></tr><tr><td><a href="#CSI">CSI</a> <a href="#v">v</a></td><td>Configuration set internals </td><td><small><a href="cif.html#gpioCfgSetInternals">gpioCfgSetInternals</a></small></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2><a name="Commands">Commands</a></h2>
<h3><a name="BC1">BC1</a>
 <a href="#bits">bits</a> - Clear specified GPIO in bank 1</h3>This command clears (sets low) the GPIO specified by <a href="#bits">bits</a> in bank 1.
Bank 1 consists of GPIO 0-31.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bc1&nbsp;0x400010&nbsp;#&nbsp;clear&nbsp;GPIO&nbsp;4&nbsp;(1&lt;&lt;4)&nbsp;and&nbsp;22&nbsp;(1&lt;&lt;22)<br><br>$&nbsp;pigs&nbsp;bc1&nbsp;32&nbsp;#&nbsp;clear&nbsp;GPIO&nbsp;5&nbsp;(1&lt;&lt;5)<br>-42<br>ERROR:&nbsp;no&nbsp;permission&nbsp;to&nbsp;update&nbsp;one&nbsp;or&nbsp;more&nbsp;GPIO<br></code><h3><a name="BC2">BC2</a>
 <a href="#bits">bits</a> - Clear specified GPIO in bank 2</h3>This command clears (sets low) the GPIO specified by <a href="#bits">bits</a> in bank 2.
Bank 2 consists of GPIO 32-53.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bc2&nbsp;0x8000&nbsp;#&nbsp;clear&nbsp;GPIO&nbsp;47&nbsp;(activity&nbsp;LED&nbsp;on&nbsp;A+/B+/Pi2/Pi3)<br><br>$&nbsp;pigs&nbsp;bc2&nbsp;1&nbsp;#&nbsp;clear&nbsp;GPIO&nbsp;32&nbsp;(first&nbsp;in&nbsp;bank&nbsp;2)<br>-42<br>ERROR:&nbsp;no&nbsp;permission&nbsp;to&nbsp;update&nbsp;one&nbsp;or&nbsp;more&nbsp;GPIO<br></code><h3><a name="BI2CC">BI2CC</a>
 <a href="#sda">sda</a> - Close bit bang I2C</h3>This command signals that bit banging I2C on <a href="#sda">sda</a> (and <a href="#scl">scl</a>) is no
longer required.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bi2cc&nbsp;5<br></code><h3><a name="BI2CO">BI2CO</a>
 <a href="#sda">sda</a> <a href="#scl">scl</a> <a href="#b">b</a> - Open bit bang I2C</h3>This command signals that GPIO <a href="#sda">sda</a> and <a href="#scl">scl</a> are to be used
for bit banging I2C at <a href="#b">b</a> baud.
<br><br>Bit banging I2C allows for certain operations which are not possible
with the standard I2C driver.
<br><br>o baud rates as low as 50<br>
o repeated starts<br>
o clock stretching<br>
o I2C on any pair of spare GPIO
<br><br>The baud rate may be between 50 and 500000 bits per second.
<br><br>The GPIO used for SDA and SCL must have pull-ups to 3V3 connected.  As
a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.
<h3><a name="BI2CZ">BI2CZ</a>
 <a href="#sda">sda</a> <a href="#bvs">bvs</a> - I2C bit bang multiple transactions</h3>This function executes a sequence of bit banged I2C operations.  The
operations to be performed are specified by the contents of <a href="#bvs">bvs</a>
which contains the concatenated command codes and associated data.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>Start</td><td>2</td><td>Start condition</td></tr><tr><td>Stop</td><td>3</td><td>Stop condition</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address and flags default to 0.  The address and flags maintain
their previous value until updated.
<br><br>No flags are currently defined.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53<br>start,&nbsp;write&nbsp;0x32,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x1E<br>start,&nbsp;write&nbsp;0x03,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x68<br>start,&nbsp;write&nbsp;0x1B,&nbsp;(re)start,&nbsp;read&nbsp;8&nbsp;bytes,&nbsp;stop<br>End<br><br>0x04&nbsp;0x53<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x1E<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x68<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x08&nbsp;0x03<br><br>0x00<br></code><h3><a name="BR1">BR1</a>
 - Read bank 1 GPIO</h3>This command read GPIO 0-31 (bank 1) and returns the levels as a
32-bit hexadecimal value.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;br1<br>1001C1CF<br></code><h3><a name="BR2">BR2</a>
 - Read bank 2 GPIO</h3>This command read GPIO 32-53 (bank 2) and returns the levels as a
32-bit hexadecimal value.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;br2<br>003F0000<br></code><h3><a name="BS1">BS1</a>
 <a href="#bits">bits</a> - Set specified GPIO in bank 1</h3>This command sets (sets high) the GPIO specified by <a href="#bits">bits</a> in bank 1.
Bank 1 consists of GPIO 0-31.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bs1&nbsp;16&nbsp;#&nbsp;set&nbsp;GPIO&nbsp;4&nbsp;(1&lt;&lt;4)<br><br>$&nbsp;pigs&nbsp;bs1&nbsp;1&nbsp;#&nbsp;set&nbsp;GPIO&nbsp;1&nbsp;(1&lt;&lt;0)<br>-42<br>ERROR:&nbsp;no&nbsp;permission&nbsp;to&nbsp;update&nbsp;one&nbsp;or&nbsp;more&nbsp;GPIO<br></code><h3><a name="BS2">BS2</a>
 <a href="#bits">bits</a> - Set specified GPIO in bank 2</h3>This command sets (sets high) the GPIO specified by <a href="#bits">bits</a> in bank 2.
Bank 2 consists of GPIO 32-53.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bs2&nbsp;0x40&nbsp;#&nbsp;set&nbsp;GPIO&nbsp;38&nbsp;(enable&nbsp;high&nbsp;current&nbsp;mode&nbsp;A+/B+/Pi2/Pi3)<br><br>$&nbsp;pigs&nbsp;bs2&nbsp;1&nbsp;#&nbsp;set&nbsp;GPIO&nbsp;32&nbsp;(first&nbsp;in&nbsp;bank&nbsp;2)<br>-42<br>ERROR:&nbsp;no&nbsp;permission&nbsp;to&nbsp;update&nbsp;one&nbsp;or&nbsp;more&nbsp;GPIO<br></code><h3><a name="BSCX">BSCX</a>
 <a href="#bctl">bctl</a> <a href="#bvs">bvs</a> - BSC I2C/SPI transfer</h3>This command performs a BSC I2C/SPI slave transfer as defined by
<a href="#bctl">bctl</a> with data <a href="#bvs">bvs</a>.
<br><br>This function provides a low-level interface to the SPI/I2C Slave
peripheral on the BCM chip.
<br><br>This peripheral allows the Pi to act as a hardware slave device
on an I2C or SPI bus.
<br><br>This is not a bit bang version and as such is OS timing
independent. The bus timing is handled directly by the chip.
<br><br>The output process is simple. You simply append data to the FIFO
buffer on the chip.  This works like a queue, you add data to the
queue and the master removes it.
<br><br>I can't get SPI to work properly.  I tried with a
control word of 0x303 and swapped MISO and MOSI.
<br><br>The command sets the BSC mode and writes any data <a href="#bvs">bvs</a>
to the BSC transmit FIFO.  It returns the data count (at least 1
for the status word), the status word, followed by any data bytes
read from the BSC receive FIFO.
<br><br>Note that the control word sets the BSC mode.  The BSC will stay in
that mode until a different control word is sent.
<br><br>For I2C use a control word of (I2C address &lt;&lt; 16) + 0x305.
<br><br>E.g. to talk as I2C slave with address 0x13 use 0x130305.
<br><br>GPIO used for models other than those based on the BCM2711.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>18</td><td>19</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>18</td><td>19</td><td>20</td><td>21</td></tr></tbody></table><br><br>GPIO used for models based on the BCM2711 (e.g. the Pi4B).
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>10</td><td>11</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>10</td><td>11</td><td>9</td><td>8</td></tr></tbody></table><br><br>When a zero control word is received the used GPIO will be reset
to INPUT mode.
<br><br>The control word consists of the following bits.
<br><br><code>22&nbsp;21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;IT&nbsp;HC&nbsp;TF&nbsp;IR&nbsp;RE&nbsp;TE&nbsp;BK&nbsp;EC&nbsp;ES&nbsp;PL&nbsp;PH&nbsp;I2&nbsp;SP&nbsp;EN<br></code><br><br>Bits 0-13 are copied unchanged to the BSC CR register.  See
pages 163-165 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>aaaaaaa</td><td>defines the I2C slave address (only relevant in I2C mode)</td></tr><tr><td>IT</td><td>invert transmit status flags</td></tr><tr><td>HC</td><td>enable host control</td></tr><tr><td>TF</td><td>enable test FIFO</td></tr><tr><td>IR</td><td>invert receive status flags</td></tr><tr><td>RE</td><td>enable receive</td></tr><tr><td>TE</td><td>enable transmit</td></tr><tr><td>BK</td><td>abort operation and clear FIFOs</td></tr><tr><td>EC</td><td>send control register as first I2C byte</td></tr><tr><td>ES</td><td>send status register as first I2C byte</td></tr><tr><td>PL</td><td>set SPI polarity high</td></tr><tr><td>PH</td><td>set SPI phase high</td></tr><tr><td>I2</td><td>enable I2C mode</td></tr><tr><td>SP</td><td>enable SPI mode</td></tr><tr><td>EN</td><td>enable BSC peripheral</td></tr></tbody></table><br><br>The returned status has the following format
<br><br><code>20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;RB&nbsp;TE&nbsp;RF&nbsp;TF&nbsp;RE&nbsp;TB<br></code><br><br>Bits 0-15 are copied unchanged from the BSC FR register.  See
pages 165-166 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>SSSSS</td><td>number of bytes successfully copied to transmit FIFO</td></tr><tr><td>RRRRR</td><td>number of bytes in receieve FIFO</td></tr><tr><td>TTTTT</td><td>number of bytes in transmit FIFO</td></tr><tr><td>RB</td><td>receive busy</td></tr><tr><td>TE</td><td>transmit FIFO empty</td></tr><tr><td>RF</td><td>receive FIFO full</td></tr><tr><td>TF</td><td>transmit FIFO full</td></tr><tr><td>RE</td><td>receive FIFO empty</td></tr><tr><td>TB</td><td>transmit busy</td></tr></tbody></table><br><br>This example assumes that GPIO 2/3 are connected to GPIO 18/19
(GPIO 10/11 on the BCM2711).
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bscx&nbsp;0x130305&nbsp;#&nbsp;start&nbsp;BSC&nbsp;as&nbsp;I2C&nbsp;slave&nbsp;0x13<br>1&nbsp;18<br><br>$&nbsp;i2cdetect&nbsp;-y&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;&nbsp;a&nbsp;&nbsp;b&nbsp;&nbsp;c&nbsp;&nbsp;d&nbsp;&nbsp;e&nbsp;&nbsp;f<br>00:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>10:&nbsp;--&nbsp;--&nbsp;--&nbsp;13&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>20:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>30:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>40:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>50:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>60:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>70:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br><br>$&nbsp;pigs&nbsp;i2co&nbsp;1&nbsp;0x13&nbsp;0&nbsp;#&nbsp;get&nbsp;handle&nbsp;for&nbsp;device&nbsp;0x13&nbsp;on&nbsp;bus&nbsp;1<br>0<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;90&nbsp;87&nbsp;51&nbsp;9&nbsp;23&nbsp;#&nbsp;write&nbsp;5&nbsp;bytes<br><br>$&nbsp;pigs&nbsp;bscx&nbsp;0x130305&nbsp;#&nbsp;check&nbsp;for&nbsp;data<br>6&nbsp;18&nbsp;90&nbsp;87&nbsp;51&nbsp;9&nbsp;23<br><br>$&nbsp;pigs&nbsp;bscx&nbsp;0x130305&nbsp;11&nbsp;13&nbsp;15&nbsp;17&nbsp;#&nbsp;check&nbsp;for&nbsp;data&nbsp;and&nbsp;send&nbsp;4&nbsp;bytes<br>1&nbsp;262338<br><br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;4&nbsp;#&nbsp;read&nbsp;4&nbsp;bytes<br>4&nbsp;11&nbsp;13&nbsp;15&nbsp;17<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;90&nbsp;87&nbsp;51&nbsp;9&nbsp;23&nbsp;#&nbsp;write&nbsp;5&nbsp;bytes<br>$&nbsp;pigs&nbsp;bscx&nbsp;0x130305&nbsp;11&nbsp;13&nbsp;15&nbsp;17&nbsp;#&nbsp;check&nbsp;for&nbsp;data&nbsp;and&nbsp;send&nbsp;4&nbsp;bytes<br>6&nbsp;262338&nbsp;90&nbsp;87&nbsp;51&nbsp;9&nbsp;23<br><br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;4<br>4&nbsp;11&nbsp;13&nbsp;15&nbsp;17<br><br>$&nbsp;pigs&nbsp;bscx&nbsp;0x130305&nbsp;22&nbsp;33&nbsp;44&nbsp;55&nbsp;66<br>1&nbsp;327938<br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;5<br>5&nbsp;22&nbsp;33&nbsp;44&nbsp;55&nbsp;66<br></code><h3><a name="BSPIC">BSPIC</a>
 <a href="#cs">cs</a> - Close bit bang SPI</h3>This command stops bit banging SPI on a set of GPIO
opened with <a href="#BSPIO">BSPIO</a>.
<br><br>The set of GPIO is specifed by <a href="#cs">cs</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bspic&nbsp;10<br><br>$&nbsp;pigs&nbsp;bspic&nbsp;10<br>-142<br>ERROR:&nbsp;no&nbsp;bit&nbsp;bang&nbsp;SPI&nbsp;in&nbsp;progress&nbsp;on&nbsp;GPIO<br></code><h3><a name="BSPIO">BSPIO</a>
 <a href="#cs">cs</a> <a href="#miso">miso</a> <a href="#mosi">mosi</a> <a href="#sclk">sclk</a> <a href="#b">b</a> <a href="#spf">spf</a> - Open bit bang SPI</h3>This command starts bit banging SPI on a group of GPIO with slave
select <a href="#cs">cs</a>, MISO <a href="#miso">miso</a>, MOSI <a href="#mosi">mosi</a>, and clock <a href="#sclk">sclk</a>.
<br><br>Data will be transferred at baud <a href="#b">b</a> bits per second (which may
be set in the range 50-250000).
<br><br>The flags <a href="#spf">spf</a> may be used to modify the default behaviour of
mode 0, active low chip select.
<br><br>The flags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;p&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode.
<br><br><code>Mode&nbsp;POL&nbsp;PHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1<br></code><br><br>p is 0 if CS is active low (default) and 1 for active high.
<br><br>T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.
<br><br>R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.
<br><br>The other bits in flags should be set to zero.
<br><br>Upon success 0 is returned.  On error a negative status code
will be returned.
<br><br>If more than one device is connected to the SPI bus (defined by
SCLK, MOSI, and MISO) each must have its own CS.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bspio&nbsp;&nbsp;9&nbsp;11&nbsp;12&nbsp;13&nbsp;50000&nbsp;0<br><br>$&nbsp;pigs&nbsp;bspio&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;50000&nbsp;0<br><br>$&nbsp;pigs&nbsp;bspio&nbsp;29&nbsp;19&nbsp;20&nbsp;21&nbsp;50000&nbsp;0&nbsp;#&nbsp;GPIO&nbsp;29&nbsp;not&nbsp;avaialble&nbsp;on&nbsp;this&nbsp;Pi<br>-41<br>ERROR:&nbsp;no&nbsp;permission&nbsp;to&nbsp;update&nbsp;GPIO<br></code><h3><a name="BSPIX">BSPIX</a>
 <a href="#cs">cs</a> <a href="#bvs">bvs</a> - SPI bit bang transfer</h3>This command writes bytes <a href="#bvs">bvs</a> to the bit bang SPI device
associated with slave select <a href="#cs">cs</a>.  It returns the same
number of bytes read from the device.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;bspio&nbsp;5&nbsp;13&nbsp;19&nbsp;12&nbsp;10000&nbsp;0&nbsp;#&nbsp;MCP4251&nbsp;DAC<br>$&nbsp;pigs&nbsp;bspio&nbsp;6&nbsp;13&nbsp;19&nbsp;12&nbsp;20000&nbsp;3&nbsp;#&nbsp;MCP3008&nbsp;ADC<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;5&nbsp;0&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;set&nbsp;DAC&nbsp;to&nbsp;16<br>2&nbsp;255&nbsp;255<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;5&nbsp;12&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;read&nbsp;back&nbsp;DAC<br>2&nbsp;254&nbsp;16<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;6&nbsp;1&nbsp;128&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;read&nbsp;ADC&nbsp;input&nbsp;0<br>3&nbsp;0&nbsp;3&nbsp;184&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;952<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;5&nbsp;0&nbsp;240&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;set&nbsp;DAC&nbsp;to&nbsp;240<br>2&nbsp;255&nbsp;255<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;5&nbsp;12&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;read&nbsp;back&nbsp;DAC<br>2&nbsp;254&nbsp;240<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;6&nbsp;1&nbsp;128&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;read&nbsp;ADC&nbsp;input&nbsp;0<br>3&nbsp;0&nbsp;0&nbsp;63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;63<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;5&nbsp;0&nbsp;128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;set&nbsp;DAC&nbsp;to&nbsp;128<br>2&nbsp;255&nbsp;255<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;5&nbsp;12&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;read&nbsp;back&nbsp;DAC<br>2&nbsp;254&nbsp;128<br><br>$&nbsp;pigs&nbsp;bspix&nbsp;6&nbsp;1&nbsp;128&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;read&nbsp;ADC&nbsp;input&nbsp;0<br>3&nbsp;0&nbsp;1&nbsp;255&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;511<br><br>$&nbsp;pigs&nbsp;bspic&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;close&nbsp;SPI&nbsp;CS&nbsp;5<br>$&nbsp;pigs&nbsp;bspic&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;close&nbsp;SPI&nbsp;CS&nbsp;6<br><br>$&nbsp;pigs&nbsp;bspic&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;try&nbsp;to&nbsp;close&nbsp;SPI&nbsp;CS&nbsp;5&nbsp;again<br>-142<br>ERROR:&nbsp;no&nbsp;bit&nbsp;bang&nbsp;SPI&nbsp;in&nbsp;progress&nbsp;on&nbsp;GPIO<br></code><h3><a name="CF1">CF1</a>
 <a href="#uvs">uvs</a> - Custom function 1</h3>This command calls a user customised function.  The meaning of
any paramaters and the returned value is defined by the
customiser.
<h3><a name="CF2">CF2</a>
 <a href="#uvs">uvs</a> - Custom function 2</h3>This command calls a user customised function.  The meaning of
any paramaters and the returned value is defined by the
customiser.
<h3><a name="CGI">CGI</a>
 - Configuration get internals</h3>This command returns the value of the internal library
configuration settings.
<h3><a name="CSI">CSI</a>
 <a href="#v">v</a> - Configuration set internals</h3>This command sets the value of the internal library
configuration settings to <a href="#v">v</a>.
<h3><a name="EVM">EVM</a>
 <a href="#h">h</a> <a href="#bits">bits</a> - Set events to monitor</h3>This command starts event reporting on handle <a href="#h">h</a> (returned by
a prior call to <a href="#NO">NO</a>).
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The notification gets reports for each event specified by <a href="#bits">bits</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;evm&nbsp;0&nbsp;-1&nbsp;#&nbsp;Shorthand&nbsp;for&nbsp;events&nbsp;0-31.<br>$&nbsp;pigs&nbsp;evm&nbsp;0&nbsp;0xf0&nbsp;#&nbsp;Get&nbsp;notifications&nbsp;for&nbsp;events&nbsp;4-7.<br><br>$&nbsp;pigs&nbsp;evm&nbsp;1&nbsp;0xf<br>-25<br>ERROR:&nbsp;unknown&nbsp;handle<br></code><h3><a name="EVT">EVT</a>
 <a href="#event">event</a> - Trigger event</h3>This command triggers event <a href="#event">event</a>.
<br><br>One event, number 31, is predefined.  This event is
auto generated on BSC slave activity.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;evt&nbsp;12<br>$&nbsp;pigs&nbsp;evt&nbsp;5<br><br>$&nbsp;pigs&nbsp;evt&nbsp;32<br>-143<br>ERROR:&nbsp;bad&nbsp;event&nbsp;id<br></code><h3><a name="FC">FC</a>
 <a href="#h">h</a> - Close file handle</h3>This command closes a file handle <a href="#h">h</a> previously opened with <a href="#FO">FO</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;fc&nbsp;0&nbsp;#&nbsp;First&nbsp;close&nbsp;okay.<br><br>$&nbsp;pigs&nbsp;fc&nbsp;0&nbsp;#&nbsp;Second&nbsp;fails.<br>-25<br>ERROR:&nbsp;unknown&nbsp;handle<br></code><h3><a name="FG">FG</a>
 <a href="#u">u</a> <a href="#stdy">stdy</a> - Set a glitch filter on a GPIO</h3>Level changes on the GPIO <a href="#u">u</a> are not reported unless the level
has been stable for at least <a href="#stdy">stdy</a> microseconds.  The
level is then reported.  Level changes of less than <a href="#stdy">stdy</a>
microseconds are ignored.
<br><br>The filter only affects callbacks (including pipe notifications).
<br><br>The <a href="#R/READ">R/READ</a>, <a href="#BR1">BR1</a>, and <a href="#BR2">BR2</a> commands are not affected.
<br><br>Note, each (stable) edge will be timestamped <a href="#stdy">stdy</a> microseconds
after it was first detected.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;fg&nbsp;4&nbsp;250<br><br>$&nbsp;pigs&nbsp;fg&nbsp;4&nbsp;1000000<br>-125<br>ERROR:&nbsp;bad&nbsp;filter&nbsp;parameter<br></code><h3><a name="FL">FL</a>
 <a href="#pat">pat</a> <a href="#num">num</a> - List files which match pattern</h3>This command returns a list of the files matching <a href="#pat">pat</a>. Up
to <a href="#num">num</a> bytes may be returned.
<br><br>Upon success the count of returned bytes followed by the matching
files is returned.  On error a negative status code will be returned.
<br><br>A newline (0x0a) character separates each file name.
<br><br>Only files which have a matching entry in /opt/pigpio/access may
be listed.
<br><br>Suppose /opt/pigpio/access contains
<br><br>/sys/bus/w1/devices/28*/w1_slave r
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;-a&nbsp;fl&nbsp;"/sys/bus/w1/devices/28*/w1_slave"&nbsp;5000<br>90&nbsp;/sys/bus/w1/devices/28-000005d34cd2/w1_slave<br>/sys/bus/w1/devices/28-001414abbeff/w1_slave<br><br>$&nbsp;pigs&nbsp;-a&nbsp;fl&nbsp;"/sys/bus/*"&nbsp;5000<br>ERROR:&nbsp;no&nbsp;permission&nbsp;to&nbsp;access&nbsp;file<br>-137<br></code><h3><a name="FN">FN</a>
 <a href="#u">u</a> <a href="#stdy">stdy</a> <a href="#actv">actv</a> - Set a noise filter on a GPIO</h3>Level changes on the GPIO <a href="#u">u</a> are ignored until a level which has
been stable for <a href="#stdy">stdy</a> microseconds is detected.  Level
changes on the GPIO are then reported for <a href="#actv">actv</a> microseconds
after which the process repeats.
<br><br>The filter only affects callbacks (including pipe notifications).
<br><br>The <a href="#R/READ">R/READ</a>, <a href="#BR1">BR1</a>, and <a href="#BR2">BR2</a> commands are not affected.
<br><br>Note, level changes before and after the active period may
be reported.  Your software must be designed to cope with
such reports.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;fn&nbsp;7&nbsp;250&nbsp;1000<br><br>$&nbsp;pigs&nbsp;fn&nbsp;7&nbsp;2500000&nbsp;1000<br>-125<br>ERROR:&nbsp;bad&nbsp;filter&nbsp;parameter<br></code><h3><a name="FO">FO</a>
 <a href="#file">file</a> <a href="#mode">mode</a> - Open a file in mode</h3>This function returns a handle to a file <a href="#file">file</a> opened
in a specified mode <a href="#mode">mode</a>.
<br><br>Upon success a handle (&gt;=0) is returned.  On error a negative status code
will be returned.
<br><br>File
<br><br>A file may only be opened if permission is granted by an entry in
/opt/pigpio/access.  This is intended to allow remote access to files
in a more or less controlled manner.
<br><br>Each entry in /opt/pigpio/access takes the form of a file path
which may contain wildcards followed by a single letter permission.
The permission may be R for read, W for write, U for read/write,
and N for no access.
<br><br>Where more than one entry matches a file the most specific rule
applies.  If no entry matches a file then access is denied.
<br><br>Suppose /opt/pigpio/access contains the following entries
<br><br><code>/home/*&nbsp;n<br>/home/pi/shared/dir_1/*&nbsp;w<br>/home/pi/shared/dir_2/*&nbsp;r<br>/home/pi/shared/dir_3/*&nbsp;u<br>/home/pi/shared/dir_1/file.txt&nbsp;n<br></code><br><br>Files may be written in directory dir_1 with the exception
of file.txt.
<br><br>Files may be read in directory dir_2.
<br><br>Files may be read and written in directory dir_3.
<br><br>If a directory allows read, write, or read/write access then files may
be created in that directory.
<br><br>In an attempt to prevent risky permissions the following paths are
ignored in /opt/pigpio/access.
<br><br><code>a&nbsp;path&nbsp;containing&nbsp;..<br>a&nbsp;path&nbsp;containing&nbsp;only&nbsp;wildcards&nbsp;(*?)<br>a&nbsp;path&nbsp;containing&nbsp;less&nbsp;than&nbsp;two&nbsp;non-wildcard&nbsp;parts<br></code><br><br>Mode
<br><br>The mode may have the following values.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>Value</td><td>Meaning</td></tr><tr><td>READ</td><td>1</td><td>open file for reading</td></tr><tr><td>WRITE</td><td>2</td><td>open file for writing</td></tr><tr><td>RW</td><td>3</td><td>open file for reading and writing</td></tr></tbody></table><br><br>The following values may be or'd into the mode.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>Value</td><td>Meaning</td></tr><tr><td>APPEND</td><td>4</td><td>All writes append data to the end of the file</td></tr><tr><td>CREATE</td><td>8</td><td>The file is created if it doesn't exist</td></tr><tr><td>TRUNC</td><td>16</td><td>The file is truncated</td></tr></tbody></table><br><br>Newly created files are owned by root with permissions owner read and write.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;ls&nbsp;/ram/*.c<br>/ram/command.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ram/pigpiod.c&nbsp;&nbsp;/ram/pigs.c<br>/ram/x_pigpiod_if.c&nbsp;/ram/pig2vcd.c&nbsp;&nbsp;/ram/pigpiod_if2.c<br>/ram/x_pigpio.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/ram/x_repeat.c&nbsp;/ram/pigpio.c<br>/ram/pigpiod_if.c&nbsp;&nbsp;&nbsp;/ram/x_pigpiod_if2.c<br><br>#&nbsp;assumes&nbsp;/opt/pigpio/access&nbsp;contains&nbsp;the&nbsp;following&nbsp;line<br>#&nbsp;/ram/*.c&nbsp;r<br><br>$&nbsp;pigs&nbsp;fo&nbsp;/ram/pigpio.c&nbsp;1<br>0<br><br>$&nbsp;pigs&nbsp;fo&nbsp;/ram/new.c&nbsp;1<br>-128<br>ERROR:&nbsp;file&nbsp;open&nbsp;failed<br><br>$&nbsp;pigs&nbsp;fo&nbsp;/ram/new.c&nbsp;9<br>1<br><br>$&nbsp;ls&nbsp;/ram/*.c&nbsp;-l<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;42923&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/command.c<br>-rw-------&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;Jul&nbsp;10&nbsp;16:54&nbsp;/ram/new.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;&nbsp;2971&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/pig2vcd.c<br>-rw-------&nbsp;1&nbsp;joan&nbsp;joan&nbsp;296235&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/pigpio.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;&nbsp;9266&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/pigpiod.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;37331&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/pigpiod_if2.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;33088&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/pigpiod_if.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;&nbsp;7990&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/pigs.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;19970&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/x_pigpio.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;20804&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/x_pigpiod_if2.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;19844&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/x_pigpiod_if.c<br>-rw-r--r--&nbsp;1&nbsp;joan&nbsp;joan&nbsp;&nbsp;19907&nbsp;Jul&nbsp;10&nbsp;11:22&nbsp;/ram/x_repeat.c<br></code><h3><a name="FR">FR</a>
 <a href="#h">h</a> <a href="#num">num</a> - Read bytes from file handle</h3>This command returns up to <a href="#num">num</a> bytes of data read from the
file associated with handle <a href="#h">h</a>.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;fr&nbsp;0&nbsp;10<br>5&nbsp;48&nbsp;49&nbsp;128&nbsp;144&nbsp;255<br><br>$&nbsp;pigs&nbsp;fr&nbsp;0&nbsp;10<br>0<br></code><h3><a name="FS">FS</a>
 <a href="#h">h</a> <a href="#num">num</a> <a href="#from">from</a> - Seek to file handle position</h3>This command seeks to a position within the file associated
with handle <a href="#h">h</a>.
<br><br>The number of bytes to move is <a href="#num">num</a>.  Positive offsets
move forward, negative offsets backwards.  The move start
position is determined by <a href="#from">from</a> as follows.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>From</td></tr><tr><td>0</td><td>start</td></tr><tr><td>1</td><td>current position</td></tr><tr><td>2</td><td>end</td></tr></tbody></table><br><br>Upon success the new byte position within the file (&gt;=0) is
returned.  On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;fs&nbsp;0&nbsp;200&nbsp;0&nbsp;#&nbsp;Seek&nbsp;to&nbsp;start&nbsp;of&nbsp;file&nbsp;plus&nbsp;200<br>200<br><br>$&nbsp;pigs&nbsp;fs&nbsp;0&nbsp;0&nbsp;1&nbsp;#&nbsp;Return&nbsp;current&nbsp;position<br>200<br><br>$&nbsp;pigs&nbsp;fs&nbsp;0&nbsp;0&nbsp;2&nbsp;#&nbsp;Seek&nbsp;to&nbsp;end&nbsp;of&nbsp;file,&nbsp;return&nbsp;size<br>296235<br></code><h3><a name="FW">FW</a>
 <a href="#h">h</a> <a href="#bvs">bvs</a> - Write bytes to file handle</h3>This command writes bytes <a href="#bvs">bvs</a> to the file
associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;fw&nbsp;0&nbsp;23&nbsp;45&nbsp;67&nbsp;89<br></code><h3><a name="GDC">GDC</a>
 <a href="#u">u</a> - Get GPIO PWM dutycycle</h3>This command returns the PWM dutycycle in use on GPIO <a href="#u">u</a>.
<br><br>Upon success the dutycycle is returned.  On error a negative
status code will be returned.
<br><br>For normal PWM the dutycycle will be out of the defined range
for the GPIO (see <a href="#PRG">PRG</a>).
<br><br>If a hardware clock is active on the GPIO the reported
dutycycle will be 500000 (500k) out of 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported dutycycle
will be out of a 1000000 (1M).
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;p&nbsp;4&nbsp;129<br>$&nbsp;pigs&nbsp;gdc&nbsp;4<br>129<br><br>pigs&nbsp;gdc&nbsp;5<br>-92<br>ERROR:&nbsp;GPIO&nbsp;is&nbsp;not&nbsp;in&nbsp;use&nbsp;for&nbsp;PWM<br></code><h3><a name="GPW">GPW</a>
 <a href="#u">u</a> - Get GPIO servo pulsewidth</h3>This command returns the servo pulsewidth in use on GPIO <a href="#u">u</a>.
<br><br>Upon success the servo pulsewidth is returned.  On error a negative
status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;s&nbsp;4&nbsp;1235<br>$&nbsp;pigs&nbsp;gpw&nbsp;4<br>1235<br><br>$&nbsp;pigs&nbsp;gpw&nbsp;9<br>-93<br>ERROR:&nbsp;GPIO&nbsp;is&nbsp;not&nbsp;in&nbsp;use&nbsp;for&nbsp;servo&nbsp;pulses<br></code><h3><a name="H/HELP">H/HELP</a>
 - Display command help</h3>This command displays a brief list of the commands and their parameters.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;h<br><br>$&nbsp;pigs&nbsp;help<br></code><h3><a name="HC">HC</a>
 <a href="#g">g</a> <a href="#cf">cf</a> - Set hardware clock frequency</h3>This command sets the hardware clock associated with GPIO <a href="#g">g</a> to
frequency <a href="#cf">cf</a>. Frequencies above 30MHz are unlikely to work.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;hc&nbsp;4&nbsp;5000&nbsp;#&nbsp;start&nbsp;a&nbsp;5&nbsp;KHz&nbsp;clock&nbsp;on&nbsp;GPIO&nbsp;4&nbsp;(clock&nbsp;0)<br><br>$&nbsp;pigs&nbsp;hc&nbsp;5&nbsp;5000000&nbsp;#&nbsp;start&nbsp;a&nbsp;5&nbsp;MHz&nbsp;clcok&nbsp;on&nbsp;GPIO&nbsp;5&nbsp;(clock&nbsp;1)<br>-99<br>ERROR:&nbsp;need&nbsp;password&nbsp;to&nbsp;use&nbsp;hardware&nbsp;clock&nbsp;1<br></code><br><br>The same clock is available on multiple GPIO.  The latest
frequency setting will be used by all GPIO which share a clock.
<br><br>The GPIO must be one of the following.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>4</td><td>clock 0</td><td>All models</td></tr><tr><td>5</td><td>clock 1</td><td>All models but A and B (reserved for system use)</td></tr><tr><td>6</td><td>clock 2</td><td>All models but A and B</td></tr><tr><td>20</td><td>clock 0</td><td>All models but A and B</td></tr><tr><td>21</td><td>clock 1</td><td>All models but A and B Rev.2 (reserved for system use)</td></tr></tbody></table><br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>32</td><td>clock 0</td><td>Compute module only</td></tr><tr><td>34</td><td>clock 0</td><td>Compute module only</td></tr><tr><td>42</td><td>clock 1</td><td>Compute module only (reserved for system use)</td></tr><tr><td>43</td><td>clock 2</td><td>Compute module only</td></tr><tr><td>44</td><td>clock 1</td><td>Compute module only (reserved for system use)</td></tr></tbody></table><br><br>Access to clock 1 is protected by a password as its use will
likely crash the Pi.  The password is given by or'ing 0x5A000000
with the GPIO number.
<h3><a name="HP">HP</a>
 <a href="#g">g</a> <a href="#pf">pf</a> <a href="#pdc">pdc</a> - Set hardware PWM frequency and dutycycle</h3>This command sets the hardware PWM associated with GPIO <a href="#g">g</a> to
frequency <a href="#pf">pf</a> with dutycycle <a href="#pdc">pdc</a>. Frequencies above 30MHz
are unlikely to work.
<br><br>NOTE: Any waveform started by <a href="#WVTX">WVTX</a>, <a href="#WVTXR">WVTXR</a>, or <a href="#WVCHA">WVCHA</a>
will be cancelled.
<br><br>This function is only valid if the pigpio main clock is PCM.  The
main clock defaults to PCM but may be overridden when the pigpio
daemon is started (option -t).
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><code>$&nbsp;pigs&nbsp;hp&nbsp;18&nbsp;100&nbsp;800000&nbsp;#&nbsp;80%&nbsp;dutycycle<br><br>$&nbsp;pigs&nbsp;hp&nbsp;19&nbsp;100&nbsp;200000&nbsp;#&nbsp;20%&nbsp;dutycycle<br><br>$&nbsp;pigs&nbsp;hp&nbsp;19&nbsp;400000000&nbsp;100000<br>-96<br>ERROR:&nbsp;invalid&nbsp;hardware&nbsp;PWM&nbsp;frequency<br></code><br><br>The same PWM channel is available on multiple GPIO.  The latest
frequency and dutycycle setting will be used by all GPIO which
share a PWM channel.
<br><br>The GPIO must be one of the following.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>12</td><td>PWM channel 0</td><td>All models but A and B</td></tr><tr><td>13</td><td>PWM channel 1</td><td>All models but A and B</td></tr><tr><td>18</td><td>PWM channel 0</td><td>All models</td></tr><tr><td>19</td><td>PWM channel 1</td><td>All models but A and B</td></tr></tbody></table><br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>40</td><td>PWM channel 0</td><td>Compute module only</td></tr><tr><td>41</td><td>PWM channel 1</td><td>Compute module only</td></tr><tr><td>45</td><td>PWM channel 1</td><td>Compute module only</td></tr><tr><td>52</td><td>PWM channel 0</td><td>Compute module only</td></tr><tr><td>53</td><td>PWM channel 1</td><td>Compute module only</td></tr></tbody></table><br><br>The actual number of steps beween off and fully on is the
integral part of 250M/<a href="#pf">pf</a> (375M/<a href="#pf">pf</a> for the BCM2711).
<br><br>The actual frequency set is 250M/steps (375M/steps for the BCM2711).
<br><br>There will only be a million steps for a <a href="#pf">pf</a> of 250 (375 for
the BCM2711). Lower frequencies will have more steps and higher
frequencies will have fewer steps.  <a href="#pdc">pdc</a> is
automatically scaled to take this into account.
<h3><a name="HWVER">HWVER</a>
 - Get hardware version</h3>This command returns the hardware revision of the Pi.
<br><br>The hardware revision is found in the last 4 characters on the revision
line of /proc/cpuinfo.
<br><br>If the hardware revision can not be found or is not a valid hexadecimal
number the command returns 0.
<br><br>The revision number can be used to determine the assignment of GPIO
to pins (see <a href="#g">g</a>).
<br><br>There are currently three types of board.
<br><br>Type 1 boards have hardware revision numbers of 2 and 3.
<br><br>Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.
<br><br>Type 3 boards have hardware revision numbers of 16 or greater.
<br><br>for "Revision : 0002" the command returns 2.
<br><br>for "Revision : 000f" the command returns 15.
<br><br>for "Revision : 000g" the command returns 0.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;hwver&nbsp;#&nbsp;On&nbsp;a&nbsp;B+<br>16<br></code><h3><a name="I2CC">I2CC</a>
 <a href="#h">h</a> - Close I2C handle</h3>This command closes an I2C handle <a href="#h">h</a> previously opened with <a href="#I2CO">I2CO</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cc&nbsp;0&nbsp;#&nbsp;First&nbsp;close&nbsp;okay.<br><br>$&nbsp;pigs&nbsp;i2cc&nbsp;0&nbsp;#&nbsp;Second&nbsp;fails.<br>-25<br>ERROR:&nbsp;unknown&nbsp;handle<br></code><h3><a name="I2CO">I2CO</a>
 <a href="#ib">ib</a> <a href="#id">id</a> <a href="#if">if</a> - Open I2C bus and device with flags</h3>This command returns a handle to access device <a href="#id">id</a> on I2C bus <a href="#ib">ib</a>.
The device is opened with flags <a href="#if">if</a>.
<br><br>Physically buses 0 and 1 are available on the Pi.  Higher
numbered buses will be available if a kernel supported bus
multiplexor is being used.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td></tr><tr><td>I2C 0</td><td>0</td><td>1</td></tr><tr><td>I2C 1</td><td>2</td><td>3</td></tr></tbody></table><br><br>No flags are currently defined.  The parameter <a href="#if">if</a> should be 0.
<br><br>Upon success the next free handle (&gt;=0) is returned.  On error a
negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2co&nbsp;1&nbsp;0x70&nbsp;0&nbsp;#&nbsp;Bus&nbsp;1,&nbsp;device&nbsp;0x70,&nbsp;flags&nbsp;0.<br>0<br><br>$&nbsp;pigs&nbsp;i2co&nbsp;1&nbsp;0x53&nbsp;0&nbsp;#&nbsp;Bus&nbsp;1,&nbsp;device&nbsp;0x53,&nbsp;flags&nbsp;0.<br>1<br></code><h3><a name="I2CPC">I2CPC</a>
 <a href="#h">h</a> <a href="#r">r</a> <a href="#wv">wv</a> - smb Process Call: exchange register with word</h3>This command writes <a href="#wv">wv</a> to register <a href="#r">r</a> of the I2C device
associated with handle <a href="#h">h</a> and returns a 16-bit word read from the
device.
<br><br>Upon success a value between 0 and 65535 will be returned.  On error
a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cpc&nbsp;0&nbsp;37&nbsp;43210<br>39933<br><br>$&nbsp;pigs&nbsp;i2cpc&nbsp;0&nbsp;256&nbsp;43210<br>ERROR:&nbsp;bad&nbsp;i2c/spi/ser&nbsp;parameter<br>-81<br></code><h3><a name="I2CPK">I2CPK</a>
 <a href="#h">h</a> <a href="#r">r</a> <a href="#bvs">bvs</a> - smb Block Process Call: exchange data bytes with register</h3>This command writes the data bytes <a href="#bvs">bvs</a> to register <a href="#r">r</a> of the I2C device
associated with handle <a href="#h">h</a> and returns a device specific number of bytes.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cpk&nbsp;0&nbsp;0&nbsp;0x11&nbsp;0x12<br>6&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br></code><h3><a name="I2CRB">I2CRB</a>
 <a href="#h">h</a> <a href="#r">r</a> - smb Read Byte Data: read byte from register</h3>This command returns a single byte read from register <a href="#r">r</a> of the I2C device
associated with handle <a href="#h">h</a>.
<br><br>Upon success a value between 0 and 255 will be returned.  On error
a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2crb&nbsp;0&nbsp;0<br>6<br></code><h3><a name="I2CRD">I2CRD</a>
 <a href="#h">h</a> <a href="#num">num</a> - i2c Read device</h3>This command returns <a href="#num">num</a> bytes read from the I2C device associated with
handle <a href="#h">h</a>.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br>This command operates on the raw I2C device.  The maximum value of the
parameter <a href="#num">num</a> is dependent on the I2C drivers and the device
itself. pigs imposes a limit of about 8000 bytes.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;16<br>16&nbsp;6&nbsp;24&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;32&nbsp;78<br></code><h3><a name="I2CRI">I2CRI</a>
 <a href="#h">h</a> <a href="#r">r</a> <a href="#num">num</a> - smb Read I2C Block Data: read bytes from register</h3>This command returns <a href="#num">num</a> bytes from register <a href="#r">r</a> of the I2C device
associated with handle <a href="#h">h</a>.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br>The parameter <a href="#num">num</a> may be 1-32.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cri&nbsp;0&nbsp;0&nbsp;16<br>16&nbsp;237&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155&nbsp;155<br></code><h3><a name="I2CRK">I2CRK</a>
 <a href="#h">h</a> <a href="#r">r</a> - smb Read Block Data: read data from register</h3>This command returns between 1 and 32 bytes read from register <a href="#r">r</a> of
the I2C device associated with handle <a href="#h">h</a>.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br>The number of bytes of returned data is specific to the device and
register.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2crk&nbsp;0&nbsp;0<br>6&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br><br>$&nbsp;pigs&nbsp;i2crk&nbsp;0&nbsp;1<br>24&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;120&nbsp;222&nbsp;105&nbsp;215&nbsp;128&nbsp;87&nbsp;195&nbsp;217&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br></code><h3><a name="I2CRS">I2CRS</a>
 <a href="#h">h</a> - smb Read Byte: read byte</h3>This command returns a single byte read from the I2C device
associated with handle <a href="#h">h</a>.
<br><br>Upon success a value between 0 and 255 will be returned.  On error
a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2crs&nbsp;0<br>0<br></code><h3><a name="I2CRW">I2CRW</a>
 <a href="#h">h</a> <a href="#r">r</a> - smb Read Word Data: read word from register</h3>This command returns a single 16 bit word read from register <a href="#r">r</a> of
the I2C device associated with handle <a href="#h">h</a>.
<br><br>Upon success a value between 0 and 65535 will be returned.  On error
a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2crw&nbsp;0&nbsp;0<br>6150<br></code><h3><a name="I2CWB">I2CWB</a>
 <a href="#h">h</a> <a href="#r">r</a> <a href="#bv">bv</a> - smb Write Byte Data: write byte to register</h3>This command writes a single byte <a href="#bv">bv</a> to register <a href="#r">r</a> of the
I2C device associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cwb&nbsp;0&nbsp;10&nbsp;0x54<br></code><h3><a name="I2CWD">I2CWD</a>
 <a href="#h">h</a> <a href="#bvs">bvs</a> - i2c Write device</h3>This command writes a block of bytes <a href="#bvs">bvs</a> to the I2C device
associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The number of bytes which may be written in one transaction is
dependent on the I2C drivers and the device itself.  pigs imposes
a limit of about 500 bytes.
<br><br>This command operates on the raw I2C device.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;0x01&nbsp;0x02&nbsp;0x03&nbsp;0x04<br></code><h3><a name="I2CWI">I2CWI</a>
 <a href="#h">h</a> <a href="#r">r</a> <a href="#bvs">bvs</a> - smb Write I2C Block Data</h3>This command writes between 1 and 32 bytes <a href="#bvs">bvs</a> to register <a href="#r">r</a> of
the I2C device associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cwi&nbsp;0&nbsp;4&nbsp;0x01&nbsp;0x04&nbsp;0xc0<br></code><h3><a name="I2CWK">I2CWK</a>
 <a href="#h">h</a> <a href="#r">r</a> <a href="#bvs">bvs</a> - smb Write Block Data: write data to register</h3>This command writes between 1 and 32 bytes <a href="#bvs">bvs</a> to register <a href="#r">r</a> of
the I2C device associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>pigs&nbsp;i2cwk&nbsp;0&nbsp;4&nbsp;0x01&nbsp;0x04&nbsp;0xc0<br></code><h3><a name="I2CWQ">I2CWQ</a>
 <a href="#h">h</a> <a href="#bit">bit</a> - smb Write Quick: write bit</h3>This command writes a single <a href="#bit">bit</a> to the I2C device associated
with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cwq&nbsp;0&nbsp;1<br></code><h3><a name="I2CWS">I2CWS</a>
 <a href="#h">h</a> <a href="#bv">bv</a> - smb Write Byte: write byte</h3>This command writes a single byte <a href="#bv">bv</a> to the I2C device associated
with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cws&nbsp;0&nbsp;0x12<br><br>$&nbsp;pigs&nbsp;i2cws&nbsp;0&nbsp;0xff<br>-82<br>ERROR:&nbsp;I2C&nbsp;write&nbsp;failed<br></code><h3><a name="I2CWW">I2CWW</a>
 <a href="#h">h</a> <a href="#r">r</a> <a href="#wv">wv</a> - smb Write Word Data: write word to register</h3>This command writes a single 16 bit word <a href="#wv">wv</a> to register <a href="#r">r</a> of
the I2C device associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;i2cww&nbsp;0&nbsp;0&nbsp;0xffff<br></code><h3><a name="I2CZ">I2CZ</a>
 <a href="#h">h</a> <a href="#bvs">bvs</a> - Performs multiple I2C transactions</h3>This command executes a sequence of I2C operations.  The
operations to be performed are specified by the contents of <a href="#bvs">bvs</a>
which contains the concatenated command codes and associated data.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>On</td><td>2</td><td>Switch combined flag on</td></tr><tr><td>Off</td><td>3</td><td>Switch combined flag off</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address defaults to that associated with the handle <a href="#h">h</a>.
The flags default to 0.  The address and flags maintain their
previous value until updated.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53,&nbsp;write&nbsp;0x32,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x1E,&nbsp;write&nbsp;0x03,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x68,&nbsp;write&nbsp;0x1B,&nbsp;read&nbsp;8&nbsp;bytes<br>End<br><br>0x04&nbsp;0x53&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x1E&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x68&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x06&nbsp;0x08<br>0x00<br></code><h3><a name="M/MODES">M/MODES</a>
 <a href="#g">g</a> <a href="#m">m</a> - Set GPIO mode</h3>This command sets GPIO <a href="#g">g</a> to mode <a href="#m">m</a>, typically input (read)
or output (write).
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>Each GPIO can be configured to be in one of 8 different modes. The modes
are named Input, Output, ALT0, ALT1, ALT2, ALT3, ALT4, and ALT5.
<br><br>To set the mode use the code for the mode.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Mode</td><td>Input</td><td>Output</td><td>ALT0</td><td>ALT1</td><td>ALT2</td><td>ALT3</td><td>ALT4</td><td>ALT5</td></tr><tr><td>Code</td><td>R</td><td>W</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;m&nbsp;4&nbsp;r&nbsp;#&nbsp;Input&nbsp;(read)<br>$&nbsp;pigs&nbsp;m&nbsp;4&nbsp;w&nbsp;#&nbsp;Output&nbsp;(write)<br>$&nbsp;pigs&nbsp;m&nbsp;4&nbsp;0&nbsp;#&nbsp;ALT&nbsp;0<br>$&nbsp;pigs&nbsp;m&nbsp;4&nbsp;5&nbsp;#&nbsp;ALT&nbsp;5<br></code><h3><a name="MG/MODEG">MG/MODEG</a>
 <a href="#g">g</a> - Get GPIO mode</h3>This command returns the current mode of GPIO <a href="#g">g</a>.
<br><br>Upon success the value of the GPIO mode is returned.
On error a negative status code will be returned.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Value</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>Mode</td><td>Input</td><td>Output</td><td>ALT5</td><td>ALT4</td><td>ALT0</td><td>ALT1</td><td>ALT2</td><td>ALT3</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;mg&nbsp;4<br>1<br></code><h3><a name="MICS">MICS</a>
 <a href="#v">v</a> - Microseconds delay</h3>This command delays execution for <a href="#v">v</a> microseconds.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The main use of this command is expected to be within <a href="#Scripts">Scripts</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;mics&nbsp;20&nbsp;#&nbsp;Delay&nbsp;20&nbsp;microseconds.<br>$&nbsp;pigs&nbsp;mics&nbsp;1000000&nbsp;#&nbsp;Delay&nbsp;1&nbsp;second.<br><br>$&nbsp;pigs&nbsp;mics&nbsp;2000000<br>-64<br>ERROR:&nbsp;bad&nbsp;MICS&nbsp;delay&nbsp;(too&nbsp;large)<br></code><h3><a name="MILS">MILS</a>
 <a href="#v">v</a> - Milliseconds delay</h3>This command delays execution for <a href="#v">v</a> milliseconds.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;mils&nbsp;2000&nbsp;#&nbsp;Delay&nbsp;2&nbsp;seconds.<br><br>$&nbsp;pigs&nbsp;mils&nbsp;61000<br>-65<br>ERROR:&nbsp;bad&nbsp;MILS&nbsp;delay&nbsp;(too&nbsp;large)<br></code><h3><a name="NB">NB</a>
 <a href="#h">h</a> <a href="#bits">bits</a> - Start notification</h3>This command starts notifications on handle <a href="#h">h</a> returned by
a prior call to <a href="#NO">NO</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The notification gets state changes for each GPIO specified by <a href="#bits">bits</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;nb&nbsp;0&nbsp;-1&nbsp;#&nbsp;Shorthand&nbsp;for&nbsp;GPIO&nbsp;0-31.<br>$&nbsp;pigs&nbsp;nb&nbsp;0&nbsp;0xf0&nbsp;#&nbsp;Get&nbsp;notifications&nbsp;for&nbsp;GPIO&nbsp;4-7.<br><br>$&nbsp;pigs&nbsp;nb&nbsp;1&nbsp;0xf<br>-25<br>ERROR:&nbsp;unknown&nbsp;handle<br></code><h3><a name="NC">NC</a>
 <a href="#h">h</a> - Close notification</h3>This command stops notifications on handle <a href="#h">h</a> returned by
a prior call to <a href="#NO">NO</a> and releases the handle for reuse.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;nc&nbsp;0&nbsp;#&nbsp;First&nbsp;call&nbsp;succeeds.<br><br>$&nbsp;pigs&nbsp;nc&nbsp;1&nbsp;#&nbsp;Second&nbsp;call&nbsp;fails.<br>-25<br>ERROR:&nbsp;unknown&nbsp;handle<br></code><h3><a name="NO">NO</a>
 - Request a notification</h3>This command requests a free notification handle.
<br><br>A notification is a method for being notified of GPIO state changes via a pipe.
<br><br>Upon success the command returns a handle greater than or equal to zero.
On error a negative status code will be returned.
<br><br>Notifications for handle x will be available at the pipe named /dev/pigpiox
(where x is the handle number).
<br><br>E.g. if the command returns 15 then the notifications must be read
from /dev/pigpio15.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;no<br>0<br></code><h3><a name="NP">NP</a>
 <a href="#h">h</a> - Pause notification</h3>This command pauses notifications on handle <a href="#h">h</a> returned by
a prior call to <a href="#NO">NO</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>Notifications for the handle are suspended until a new <a href="#NB">NB</a> command
is given for the handle.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;np&nbsp;0<br></code><h3><a name="P/PWM">P/PWM</a>
 <a href="#u">u</a> <a href="#v">v</a> - Set GPIO PWM value</h3>This command starts PWM on GPIO <a href="#u">u</a> with dutycycle <a href="#v">v</a>.  The dutycycle
varies from 0 (off) to range (fully on).  The range defaults to 255.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>This and the servo functionality use the DMA and PWM or PCM peripherals
to control and schedule the pulsewidths and dutycycles.
<br><br>The <a href="#PRS">PRS</a> command may be used to change the default range of 255.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;p&nbsp;4&nbsp;64&nbsp;&nbsp;#&nbsp;Start&nbsp;PWM&nbsp;on&nbsp;GPIO&nbsp;4&nbsp;with&nbsp;25%&nbsp;dutycycle<br>$&nbsp;pigs&nbsp;p&nbsp;4&nbsp;128&nbsp;#&nbsp;50%<br>$&nbsp;pigs&nbsp;p&nbsp;4&nbsp;192&nbsp;#&nbsp;75%<br>$&nbsp;pigs&nbsp;p&nbsp;4&nbsp;255&nbsp;#&nbsp;100%<br></code><h3><a name="PADG">PADG</a>
 <a href="#pad">pad</a> - Get pad drive strength</h3>This command gets the <a href="#pad">pad</a> drive strength <a href="#padma">padma</a> in mA.
<br><br>Returns the pad drive strength if OK.  On error a negative status code
will be returned.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;padg&nbsp;0<br>8<br>$&nbsp;pigs&nbsp;pads&nbsp;0&nbsp;16<br>$&nbsp;pigs&nbsp;padg&nbsp;0<br>16<br>pigs&nbsp;padg&nbsp;3<br>-126<br>ERROR:&nbsp;bad&nbsp;pad&nbsp;number<br></code><h3><a name="PADS">PADS</a>
 <a href="#pad">pad</a> <a href="#padma">padma</a> - Set pad drive strength</h3>This command sets the <a href="#pad">pad</a> drive strength <a href="#padma">padma</a> in mA.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;pads&nbsp;0&nbsp;16<br>$&nbsp;pigs&nbsp;padg&nbsp;0<br>16<br>$&nbsp;pigs&nbsp;pads&nbsp;0&nbsp;17<br>-127<br>ERROR:&nbsp;bad&nbsp;pad&nbsp;drive&nbsp;strength<br></code><h3><a name="PARSE">PARSE</a>
 <a href="#t">t</a> - Validate script</h3>Validates the text <a href="#t">t</a> of a script without storing the script.
<br><br>Upon success nothing is returned.  On error a list of detected
script errors will be given.
<br><br>See <a href="#Scripts">Scripts</a>.
<br><br>This command may be used to find script syntax faults.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;parse&nbsp;tag&nbsp;100&nbsp;w&nbsp;22&nbsp;1&nbsp;mils&nbsp;200&nbsp;w&nbsp;22&nbsp;0&nbsp;mils&nbsp;800&nbsp;jmp&nbsp;100<br><br>$&nbsp;pigs&nbsp;parse&nbsp;tag&nbsp;0&nbsp;w&nbsp;22&nbsp;1&nbsp;mills&nbsp;50&nbsp;w&nbsp;22&nbsp;0&nbsp;dcr&nbsp;p10&nbsp;jp&nbsp;99<br>Unknown&nbsp;command:&nbsp;mills<br>Unknown&nbsp;command:&nbsp;50<br>Bad&nbsp;parameter&nbsp;to&nbsp;dcr<br>Can't&nbsp;resolve&nbsp;tag&nbsp;99<br></code><h3><a name="PFG">PFG</a>
 <a href="#u">u</a> - Get GPIO PWM frequency</h3>This command returns the PWM frequency in Hz used for GPIO <a href="#u">u</a>.
<br><br>Upon success the PWM frequency is returned.  On error a negative
status code will be returned.
<br><br>For normal PWM the frequency will be that defined for the GPIO
by <a href="#PFS">PFS</a>.
<br><br>If a hardware clock is active on the GPIO the reported frequency
will be that set by <a href="#HC">HC</a>.
<br><br>If hardware PWM is active on the GPIO the reported frequency
will be that set by <a href="#HP">HP</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;pfg&nbsp;4<br>800<br><br>$&nbsp;pigs&nbsp;pfg&nbsp;34<br>ERROR:&nbsp;GPIO&nbsp;not&nbsp;0-31<br>-2<br></code><h3><a name="PFS">PFS</a>
 <a href="#u">u</a> <a href="#v">v</a> - Set GPIO PWM frequency</h3>This command sets the PWM frequency <a href="#v">v</a> to be used for GPIO <a href="#u">u</a>.
<br><br>The numerically closest frequency to <a href="#v">v</a> will be selected.
<br><br>Upon success the new frequency is returned.  On error a negative status code
will be returned.
<br><br>If PWM is currently active on the GPIO it will be
switched off and then back on at the new frequency.
<br><br>Each GPIO can be independently set to one of 18 different PWM
frequencies.
<br><br>The selectable frequencies depend upon the sample rate which
may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).  The
sample rate is set when the pigpio daemon is started.
<br><br>The frequencies for each sample rate are:
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hertz<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;40000&nbsp;20000&nbsp;10000&nbsp;8000&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1600<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1250&nbsp;&nbsp;1000&nbsp;&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;20000&nbsp;10000&nbsp;&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;800<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;625&nbsp;&nbsp;&nbsp;500&nbsp;&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;10000&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;400<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;313&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13<br>sample<br>&nbsp;rate<br>&nbsp;(us)&nbsp;&nbsp;5:&nbsp;&nbsp;8000&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;1600&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;320<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;&nbsp;160&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;313&nbsp;&nbsp;250&nbsp;&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;156&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;6<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10:&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;160<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;5<br></code><br><br><b><small>Example</small></b><br><br><code>pigs&nbsp;pfs&nbsp;4&nbsp;0&nbsp;#&nbsp;0&nbsp;selects&nbsp;the&nbsp;lowest&nbsp;frequency.<br>10<br><br>$&nbsp;pigs&nbsp;pfs&nbsp;4&nbsp;1000&nbsp;#&nbsp;Set&nbsp;1000Hz&nbsp;PWM.<br>1000<br><br>$&nbsp;pigs&nbsp;pfs&nbsp;4&nbsp;100000&nbsp;#&nbsp;Very&nbsp;big&nbsp;number&nbsp;selects&nbsp;the&nbsp;highest&nbsp;frequency.<br>8000<br></code><h3><a name="PIGPV">PIGPV</a>
 - Get pigpio library version</h3>This command returns the pigpio library version.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;pigpv<br>17<br></code><h3><a name="PRG">PRG</a>
 <a href="#u">u</a> - Get GPIO PWM range</h3>This command returns the dutycycle range for GPIO <a href="#u">u</a>.
<br><br>Upon success the range is returned.  On error a negative status code
will be returned.
<br><br>If a hardware clock or hardware PWM is active on the GPIO the reported
range will be 1000000 (1M).
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;prg&nbsp;4<br>255<br></code><h3><a name="PROC">PROC</a>
 <a href="#t">t</a> - Store script</h3>This command stores a script <a href="#t">t</a> for later execution.
<br><br>If the script is valid a script id (&gt;=0) is returned which is passed
to the other script commands. On error a negative status code
will be returned.
<br><br>See <a href="#Scripts">Scripts</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;proc&nbsp;tag&nbsp;123&nbsp;w&nbsp;4&nbsp;0&nbsp;mils&nbsp;200&nbsp;w&nbsp;4&nbsp;1&nbsp;mils&nbsp;300&nbsp;dcr&nbsp;p0&nbsp;jp&nbsp;123<br>0<br><br>$&nbsp;pigs&nbsp;proc&nbsp;tag&nbsp;123&nbsp;w&nbsp;4&nbsp;0&nbsp;mils&nbsp;5&nbsp;w&nbsp;4&nbsp;1&nbsp;mils&nbsp;5&nbsp;jmp&nbsp;12<br>ERROR:&nbsp;script&nbsp;has&nbsp;unresolved&nbsp;tag<br>-63<br></code><h3><a name="PROCD">PROCD</a>
 <a href="#sid">sid</a> - Delete script</h3>This command deletes script <a href="#sid">sid</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>See <a href="#Scripts">Scripts</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;procd&nbsp;1<br><br>$&nbsp;pigs&nbsp;procd&nbsp;1<br>ERROR:&nbsp;unknown&nbsp;script&nbsp;id<br>-48<br></code><h3><a name="PROCP">PROCP</a>
 <a href="#sid">sid</a> - Get script status and parameters</h3>This command returns the status of script <a href="#sid">sid</a> as well as the
current value of its 10 parameters.
<br><br>Upon success the script status and parameters are  returned.
On error a negative status code will be returned.
<br><br>The script status may be one of
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>0</td><td>being initialised</td></tr><tr><td>1</td><td>halted</td></tr><tr><td>2</td><td>running</td></tr><tr><td>3</td><td>waiting</td></tr><tr><td>4</td><td>failed</td></tr></tbody></table><br><br>See <a href="#Scripts">Scripts</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;procp&nbsp;0<br>1&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br></code><h3><a name="PROCR">PROCR</a>
 <a href="#sid">sid</a> <a href="#pars">pars</a> - Run script</h3>This command runs stored script <a href="#sid">sid</a> passing it up to 10 optional
parameters.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>See <a href="#Scripts">Scripts</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;proc&nbsp;tag&nbsp;123&nbsp;w&nbsp;4&nbsp;0&nbsp;mils&nbsp;200&nbsp;w&nbsp;4&nbsp;1&nbsp;mils&nbsp;300&nbsp;dcr&nbsp;p0&nbsp;jp&nbsp;123<br>0<br><br>$&nbsp;pigs&nbsp;procr&nbsp;0&nbsp;50&nbsp;#&nbsp;Run&nbsp;script&nbsp;0&nbsp;with&nbsp;parameter&nbsp;0&nbsp;of&nbsp;50.<br><br>$&nbsp;pigs&nbsp;procp&nbsp;0<br>2&nbsp;44&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br>$&nbsp;pigs&nbsp;procp&nbsp;0<br>2&nbsp;37&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br>$&nbsp;pigs&nbsp;procp&nbsp;0<br>2&nbsp;10&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br>$&nbsp;pigs&nbsp;procp&nbsp;0<br>2&nbsp;5&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br>$&nbsp;pigs&nbsp;procp&nbsp;0<br>2&nbsp;2&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br>$&nbsp;pigs&nbsp;procp&nbsp;0<br>1&nbsp;-1&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br></code><h3><a name="PROCS">PROCS</a>
 <a href="#sid">sid</a> - Stop script</h3>This command stops a running script <a href="#sid">sid</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>See <a href="#Scripts">Scripts</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;procs&nbsp;0<br><br>$&nbsp;pigs&nbsp;procs&nbsp;1<br>-48<br>ERROR:&nbsp;unknown&nbsp;script&nbsp;id<br></code><h3><a name="PROCU">PROCU</a>
 <a href="#sid">sid</a> <a href="#pars">pars</a> - Set script parameters</h3>This command sets the parameters of a stored script <a href="#sid">sid</a> passing
it up to 10 parameters.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>See <a href="#Scripts">Scripts</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;proc&nbsp;tag&nbsp;0&nbsp;hp&nbsp;18&nbsp;p0&nbsp;p1&nbsp;mils&nbsp;1000&nbsp;jmp&nbsp;0<br>0<br>$&nbsp;pigs&nbsp;procu&nbsp;0&nbsp;50&nbsp;500000<br>$&nbsp;pigs&nbsp;procr&nbsp;0<br>$&nbsp;pigs&nbsp;procu&nbsp;0&nbsp;100<br>$&nbsp;pigs&nbsp;procu&nbsp;0&nbsp;200<br>$&nbsp;pigs&nbsp;procu&nbsp;0&nbsp;200&nbsp;100000<br></code><h3><a name="PRRG">PRRG</a>
 <a href="#u">u</a> - Get GPIO PWM real range</h3>This command returns the real underlying range used by GPIO <a href="#u">u</a>.
<br><br>If a hardware clock is active on the GPIO the reported
real range will be 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported real range
will be approximately 250M divided by the set PWM frequency.
<br><br>On error a negative status code will be returned.
<br><br>See <a href="#PRS">PRS</a>.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;prrg&nbsp;17<br>250<br><br>$&nbsp;pigs&nbsp;pfs&nbsp;17&nbsp;0<br>10<br>$&nbsp;pigs&nbsp;prrg&nbsp;17<br>20000<br><br>$&nbsp;pigs&nbsp;pfs&nbsp;17&nbsp;100000<br>8000<br>$&nbsp;pigs&nbsp;prrg&nbsp;17<br>25<br></code><h3><a name="PRS">PRS</a>
 <a href="#u">u</a> <a href="#v">v</a> - Set GPIO PWM range</h3>This command sets the dutycycle range <a href="#v">v</a> to be used for GPIO <a href="#u">u</a>.
Subsequent uses of command <a href="#P/PWM">P/PWM</a> will use a dutycycle between 0 (off)
and <a href="#v">v</a> (fully on).
<br><br>Upon success the real underlying range used by the GPIO is returned.
On error a negative status code will be returned.
<br><br>If PWM is currently active on the GPIO its dutycycle will be scaled to
reflect the new range.
<br><br>The real range, the number of steps between fully off and fully on
for each frequency, is given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>#1</td><td>#2</td><td>#3</td><td>#4</td><td>#5</td><td>#6</td><td>#7</td><td>#8</td><td>#9</td></tr><tr><td>25</td><td>50</td><td>100</td><td>125</td><td>200</td><td>250</td><td>400</td><td>500</td><td>625</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>#10</td><td>#11</td><td>#12</td><td>#13</td><td>#14</td><td>#15</td><td>#16</td><td>#17</td><td>#18</td></tr><tr><td>800</td><td>1000</td><td>1250</td><td>2000</td><td>2500</td><td>4000</td><td>5000</td><td>10000</td><td>20000</td></tr></tbody></table><br><br>The real value set by <a href="#PRS">PRS</a> is (dutycycle * real range) / range.
<br><br>See <a href="#PRRG">PRRG</a>
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;prs&nbsp;18&nbsp;1000<br>250<br></code><h3><a name="PUD">PUD</a>
 <a href="#g">g</a> <a href="#p">p</a> - Set GPIO pull up/down</h3>This command sets the internal pull/up down for GPIO <a href="#g">g</a> to mode <a href="#p">p</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The mode may be pull-down (D), pull-up (U), or off (O).
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;pud&nbsp;4&nbsp;d&nbsp;#&nbsp;Set&nbsp;pull-down&nbsp;on&nbsp;GPIO&nbsp;4.<br>$&nbsp;pigs&nbsp;pud&nbsp;4&nbsp;u&nbsp;#&nbsp;Set&nbsp;pull-up&nbsp;on&nbsp;GPIO&nbsp;4.<br>$&nbsp;pigs&nbsp;pud&nbsp;4&nbsp;o&nbsp;#&nbsp;No&nbsp;pull-up/down&nbsp;on&nbsp;GPIO&nbsp;4.<br></code><h3><a name="R/READ">R/READ</a>
 <a href="#g">g</a> - Read GPIO level</h3>This reads the current level of GPIO <a href="#g">g</a>.
<br><br>Upon success the current level is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;r&nbsp;17&nbsp;#&nbsp;Get&nbsp;level&nbsp;of&nbsp;GPIO&nbsp;17.<br>0<br><br>$&nbsp;pigs&nbsp;r&nbsp;4&nbsp;#&nbsp;Get&nbsp;level&nbsp;of&nbsp;GPIO&nbsp;4.<br>1<br></code><h3><a name="S/SERVO">S/SERVO</a>
 <a href="#u">u</a> <a href="#v">v</a> - Set GPIO servo pulsewidth</h3>This command starts servo pulses of <a href="#v">v</a> microseconds on GPIO <a href="#u">u</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The servo pulsewidth may be 0 (off), 500 (most anti-clockwise)
to 2500 (most clockwise).
<br><br>The range supported by servos varies and should probably be determined
by experiment. Generally values between 1000-2000 should be safe.
A value of 1500 should always be safe and represents
the mid-point of rotation.
<br><br>You can DAMAGE a servo if you command it to move beyond its limits.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;SERVO&nbsp;17&nbsp;1500<br></code><br><br>This example causes an on pulse of 1500 microseconds duration to be
transmitted on GPIO 17 at a rate of 50 times per second.
<br><br>This will command a servo connected to GPIO 17 to rotate to its mid-point.
<br><br><b><small>Example</small></b><br><br><code>pigs&nbsp;s&nbsp;17&nbsp;0&nbsp;#&nbsp;Switch&nbsp;servo&nbsp;pulses&nbsp;off.<br></code><h3><a name="SERC">SERC</a>
 <a href="#h">h</a> - Close serial handle</h3>This command closes a serial handle <a href="#h">h</a> previously opened with <a href="#SERO">SERO</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;serc&nbsp;0&nbsp;#&nbsp;First&nbsp;close&nbsp;okay.<br><br>$&nbsp;pigs&nbsp;serc&nbsp;0&nbsp;#&nbsp;Second&nbsp;close&nbsp;gives&nbsp;error.<br>-25<br>ERROR:&nbsp;unknown&nbsp;handle<br></code><h3><a name="SERDA">SERDA</a>
 <a href="#h">h</a> - Check for serial data ready to read</h3>This command returns the number of bytes of data available
to be read from the serial device associated with handle <a href="#h">h</a>.
<br><br>Upon success the count of bytes available to be read is
returned (which may be 0).  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;serda&nbsp;0<br>0<br></code><h3><a name="SERO">SERO</a>
 <a href="#dev">dev</a> <a href="#b">b</a> <a href="#sef">sef</a> - Open serial device dev at baud b with flags</h3>This command opens the serial <a href="#dev">dev</a> at <a href="#b">b</a> bits per second.
<br><br>No flags are currently defined.  <a href="#sef">sef</a> should be set to zero.
<br><br>Upon success a handle (&gt;=0) is returned.  On error a negative status code
will be returned.
<br><br>The device name must start with /dev/tty or /dev/serial.
<br><br>The baud rate must be one of 50, 75, 110, 134, 150,
200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200,
38400, 57600, 115200, or 230400.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;sero&nbsp;/dev/ttyAMA0&nbsp;9600&nbsp;0<br>0<br><br>$&nbsp;pigs&nbsp;sero&nbsp;/dev/tty1&nbsp;38400&nbsp;0<br>1<br></code><h3><a name="SERR">SERR</a>
 <a href="#h">h</a> <a href="#num">num</a> - Read bytes from serial handle</h3>This command returns up to <a href="#num">num</a> bytes of data read from the
serial device associated with handle <a href="#h">h</a>.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;serr&nbsp;0&nbsp;10<br>5&nbsp;48&nbsp;49&nbsp;128&nbsp;144&nbsp;255<br><br>$&nbsp;pigs&nbsp;serr&nbsp;0&nbsp;10<br>0<br></code><h3><a name="SERRB">SERRB</a>
 - Read byte from serial handle</h3>This command returns a byte of data read from the serial
device associated with handle <a href="#h">h</a>.
<br><br>Upon success a number between 0 and 255 is returned.
On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;serrb&nbsp;0<br>23<br>$&nbsp;pigs&nbsp;serrb&nbsp;0<br>45<br></code><h3><a name="SERW">SERW</a>
 <a href="#h">h</a> <a href="#bvs">bvs</a> - Write bytes to serial handle</h3>This command writes bytes <a href="#bvs">bvs</a> to the serial device
associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;serw&nbsp;0&nbsp;23&nbsp;45&nbsp;67&nbsp;89<br></code><h3><a name="SERWB">SERWB</a>
 <a href="#h">h</a> <a href="#bv">bv</a> - Write byte to serial handle</h3>This command writes a single byte <a href="#bv">bv</a> to the serial device
associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;serwb&nbsp;0&nbsp;23<br>$&nbsp;pigs&nbsp;serwb&nbsp;0&nbsp;0xf0<br></code><h3><a name="SHELL">SHELL</a>
 <a href="#name">name</a> <a href="#str">str</a> - Execute a shell command</h3>This command uses the system call to execute a shell script <a href="#name">name</a>
with the given string <a href="#str">str</a> as its parameter.
<br><br>The exit status of the system call is returned if OK, otherwise
PI_BAD_SHELL_STATUS.
<br><br><a href="#name">name</a> must exist in /opt/pigpio/cgi and must be executable.
<br><br>The returned exit status is normally 256 times that set
by the shell script exit function.  If the script can't
be found 32512 will be returned.
<br><br>The following table gives some example returned statuses.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Script exit status</td><td>Returned system call status</td></tr><tr><td>1</td><td>256</td></tr><tr><td>5</td><td>1280</td></tr><tr><td>10</td><td>2560</td></tr><tr><td>200</td><td>51200</td></tr><tr><td>script not found</td><td>32512</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>#&nbsp;pass&nbsp;two&nbsp;parameters,&nbsp;hello&nbsp;and&nbsp;world<br>$&nbsp;pigs&nbsp;shell&nbsp;scr1&nbsp;hello&nbsp;world<br>256<br><br>#&nbsp;pass&nbsp;three&nbsp;parameters,&nbsp;hello,&nbsp;string&nbsp;with&nbsp;spaces,&nbsp;and&nbsp;world<br>$&nbsp;pigs&nbsp;shell&nbsp;scr1&nbsp;"hello&nbsp;'string&nbsp;with&nbsp;spaces'&nbsp;world"<br>256<br><br>#&nbsp;pass&nbsp;one&nbsp;parameter,&nbsp;hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world<br>$&nbsp;pigs&nbsp;shell&nbsp;scr1&nbsp;"\"hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world\""<br>256<br><br>#&nbsp;non-existent&nbsp;script<br>$&nbsp;pigs&nbsp;shell&nbsp;scr78&nbsp;par1<br>32512<br></code><h3><a name="SLR">SLR</a>
 <a href="#u">u</a> <a href="#num">num</a> - Read bit bang serial data from GPIO</h3>This command returns up to <a href="#num">num</a> bytes of bit bang serial data
read from GPIO <a href="#u">u</a>.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br>The GPIO <a href="#u">u</a> should have been initialised with the <a href="#SLRO">SLRO</a> command.
<br><br>The bytes returned for each character depend upon the number of
data bits <a href="#db">db</a> specified in the <a href="#SLRO">SLRO</a> command.
<br><br>For <a href="#db">db</a> 1-8 there will be one byte per character.<br>
For <a href="#db">db</a> 9-16 there will be two bytes per character.<br>
For <a href="#db">db</a> 17-32 there will be four bytes per character.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;slr&nbsp;15&nbsp;20<br>6&nbsp;1&nbsp;0&nbsp;23&nbsp;45&nbsp;89&nbsp;0<br></code><h3><a name="SLRC">SLRC</a>
 <a href="#u">u</a> - Close GPIO for bit bang serial data</h3>This command closes GPIO <a href="#u">u</a> for reading bit bang serial data.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;slrc&nbsp;23<br><br>$&nbsp;pigs&nbsp;slrc&nbsp;23<br>-38<br>ERROR:&nbsp;no&nbsp;serial&nbsp;read&nbsp;in&nbsp;progress&nbsp;on&nbsp;GPIO<br></code><h3><a name="SLRI">SLRI</a>
 <a href="#u">u</a> <a href="#v">v</a> - Sets bit bang serial data logic levels</h3>This command sets the logic level for reading bit bang serial data
on GPIO <a href="#u">u</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The invert parameter <a href="#v">v</a> is 1 for inverted signal, 0 for normal.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;slri&nbsp;17&nbsp;1&nbsp;#&nbsp;invert&nbsp;logic&nbsp;on&nbsp;GPIO&nbsp;17<br><br>$&nbsp;pigs&nbsp;slri&nbsp;23&nbsp;0&nbsp;#&nbsp;use&nbsp;normal&nbsp;logic&nbsp;on&nbsp;GPIO&nbsp;23<br></code><h3><a name="SLRO">SLRO</a>
 <a href="#u">u</a> <a href="#b">b</a> <a href="#db">db</a> - Open GPIO for bit bang serial data</h3>This command opens GPIO <a href="#u">u</a> for reading bit bang serial data
at <a href="#b">b</a> baud and <a href="#db">db</a> data bits.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The baud rate may be between 50 and 250000 bits per second.
<br><br>The received data is held in a cyclic buffer.
<br><br>It is the user's responsibility to read the data (with <a href="#SLR">SLR</a>)
in a timely fashion.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;slro&nbsp;23&nbsp;19200&nbsp;8<br><br>$&nbsp;pigs&nbsp;slro&nbsp;23&nbsp;19200&nbsp;8<br>-50<br>ERROR:&nbsp;GPIO&nbsp;already&nbsp;in&nbsp;use<br></code><h3><a name="SPIC">SPIC</a>
 <a href="#h">h</a> - SPI close handle</h3>This command closes the SPI handle <a href="#h">h</a> returned by a prior
call to <a href="#SPIO">SPIO</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;spic&nbsp;1<br><br>$&nbsp;pigs&nbsp;spic&nbsp;1<br>-25<br>ERROR:&nbsp;unknown&nbsp;handle<br></code><h3><a name="SPIO">SPIO</a>
 <a href="#c">c</a> <a href="#b">b</a> <a href="#spf">spf</a> - SPI open channel at baud b with flags</h3>This command returns a handle to a SPI device on channel <a href="#c">c</a>.
<br><br>Data will be transferred at <a href="#b">b</a> bits per second.  The flags <a href="#spf">spf</a>
may be used to modify the default behaviour of 4-wire operation,
mode 0, active low chip select.
<br><br>Speeds between 32kbps and 125Mbps are allowed.  Speeds above 30Mbps
are unlikely to work.
<br><br>The Pi has two SPI peripherals: main and auxiliary.
<br><br>The main SPI has two chip selects (channels), the auxiliary has
three.
<br><br>The auxiliary SPI is available on all models but the A and B.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>MISO</td><td>MOSI</td><td>SCLK</td><td>CE0</td><td>CE1</td><td>CE2</td></tr><tr><td>Main SPI</td><td>9</td><td>10</td><td>11</td><td>8</td><td>7</td><td>-</td></tr><tr><td>Aux SPI</td><td>19</td><td>20</td><td>21</td><td>18</td><td>17</td><td>16</td></tr></tbody></table><br><br>The flags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;W&nbsp;&nbsp;A&nbsp;u2&nbsp;u1&nbsp;u0&nbsp;p2&nbsp;p1&nbsp;p0&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode.
<br><br>Warning:  modes 1 and 3 do not appear to work on the auxiliary SPI.
<br><br><code>Mode&nbsp;POL&nbsp;PHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1<br></code><br><br>px is 0 if CEx is active low (default) and 1 for active high.
<br><br>ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.
<br><br>A is 0 for the main SPI, 1 for the auxiliary SPI.
<br><br>W is 0 if the device is not 3-wire, 1 if the device is 3-wire.  Main
SPI only.
<br><br>nnnn defines the number of bytes (0-15) to write before switching
the MOSI line to MISO to read data.  This field is ignored
if W is not set.  Main SPI only.
<br><br>T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.  Auxiliary SPI
only.
<br><br>R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.  Auxiliary SPI
only.
<br><br>bbbbbb defines the word size in bits (0-32).  The default (0)
sets 8 bits per word.  Auxiliary SPI only.
<br><br>The <a href="#SPIR">SPIR</a>, <a href="#SPIW">SPIW</a>, and <a href="#SPIX">SPIX</a> commands transfer data
packed into 1, 2, or 4 bytes according to the word size in bits.
<br><br>For bits 1-8 there will be one byte per character.<br>
For bits 9-16 there will be two bytes per character.<br>
For bits 17-32 there will be four bytes per character.
<br><br>Multi-byte transfers are made in least significant byte first order.
<br><br>E.g. to transfer 32 11-bit words 64 bytes need to be sent.
<br><br>E.g. to transfer the 14 bit value 0x1ABC send the bytes 0xBC followed
by 0x1A.
<br><br>The other bits in flags should be set to zero.
<br><br>Upon success a handle (&gt;=0) is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;spio&nbsp;0&nbsp;100000&nbsp;3&nbsp;#&nbsp;Open&nbsp;channel&nbsp;0&nbsp;at&nbsp;100kbps&nbsp;in&nbsp;mode&nbsp;3.<br>0<br><br>$&nbsp;pigs&nbsp;spio&nbsp;0&nbsp;32000&nbsp;256&nbsp;#&nbsp;Open&nbsp;channel&nbsp;0&nbsp;of&nbsp;auxiliary&nbsp;spi&nbsp;at&nbsp;32kbps.<br>1<br></code><h3><a name="SPIR">SPIR</a>
 <a href="#h">h</a> <a href="#num">num</a> - SPI read bytes from handle</h3>This command returns <a href="#num">num</a> bytes read from the SPI device
associated with handle <a href="#h">h</a>.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;spir&nbsp;0&nbsp;10&nbsp;#&nbsp;Read&nbsp;10&nbsp;bytes&nbsp;from&nbsp;the&nbsp;SPI&nbsp;device.<br>10&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br></code><h3><a name="SPIW">SPIW</a>
 <a href="#h">h</a> <a href="#bvs">bvs</a> - SPI write bytes to handle</h3>This command writes bytes <a href="#bvs">bvs</a> to the SPI device
associated with handle <a href="#h">h</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;spiw&nbsp;0&nbsp;0x22&nbsp;0x33&nbsp;0xcc&nbsp;0xff<br></code><h3><a name="SPIX">SPIX</a>
 <a href="#h">h</a> <a href="#bvs">bvs</a> - SPI transfer bytes to handle</h3>This command writes bytes <a href="#bvs">bvs</a> to the SPI device
associated with handle <a href="#h">h</a>.  It returns the same
number of bytes read from the device.
<br><br>Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;spix&nbsp;0&nbsp;0x22&nbsp;0x33&nbsp;0xcc&nbsp;0xff<br>4&nbsp;0&nbsp;0&nbsp;0&nbsp;0<br></code><h3><a name="T/TICK">T/TICK</a>
 - Get current tick</h3>This command returns the current system tick.
<br><br>Tick is the number of microseconds since system boot.
<br><br>As tick is an unsigned 32 bit quantity it wraps around after 2^32 microseconds,
which is approximately 1 hour 12 minutes.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;t&nbsp;mils&nbsp;1000&nbsp;t<br>3691823946<br>3692833987<br></code><h3><a name="TRIG">TRIG</a>
 <a href="#u">u</a> <a href="#pl">pl</a> <a href="#L">L</a> - Send a trigger pulse</h3>This command sends a trigger pulse of <a href="#pl">pl</a> microseconds at level <a href="#L">L</a>
to GPIO <a href="#u">u</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The GPIO is set to not level at the end of the pulse.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;trig&nbsp;4&nbsp;10&nbsp;1<br><br>$&nbsp;pigs&nbsp;trig&nbsp;4&nbsp;51&nbsp;1<br>-46<br>ERROR:&nbsp;trigger&nbsp;pulse&nbsp;&gt;&nbsp;50&nbsp;microseconds<br></code><h3><a name="W/WRITE">W/WRITE</a>
 <a href="#g">g</a> <a href="#L">L</a> - Write GPIO level</h3>This command sets GPIO <a href="#g">g</a> to level <a href="#L">L</a>.  The level may be 0
(low, off, clear) or 1 (high, on, set).
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;w&nbsp;23&nbsp;0<br>$&nbsp;pigs&nbsp;w&nbsp;23&nbsp;1<br><br>$&nbsp;pigs&nbsp;w&nbsp;23&nbsp;2<br>-5<br>ERROR:&nbsp;level&nbsp;not&nbsp;0-1<br></code><h3><a name="WDOG">WDOG</a>
 <a href="#u">u</a> <a href="#v">v</a> - Set GPIO watchdog</h3>This command sets a watchdog of <a href="#v">v</a> milliseconds on GPIO <a href="#u">u</a>.
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br>The watchdog is nominally in milliseconds.
<br><br>One watchdog may be registered per GPIO.
<br><br>The watchdog may be cancelled by setting timeout to 0.
<br><br>Once a watchdog has been started monitors of the GPIO
will be triggered every timeout interval after the last
GPIO activity.  The watchdog expiry will be indicated by
a special TIMEOUT value.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wdog&nbsp;23&nbsp;90000<br>-15<br>ERROR:&nbsp;timeout&nbsp;not&nbsp;0-60000<br><br>$&nbsp;pigs&nbsp;wdog&nbsp;23&nbsp;9000<br></code><br><br>This example causes a report to be written to any notification pipes
listening on GPIO 23 whenever GPIO 23 changes state or approximately
every 9000 ms.
<h3><a name="WVAG">WVAG</a>
 <a href="#trips">trips</a> - Add generic pulses to waveform</h3>This command adds 1 one or more triplets <a href="#trips">trips</a> of GPIO on, GPIO off,
delay to the existing waveform (if any).
<br><br>Upon success the total number of pulses in the waveform so far is
returned.  On error a negative status code will be returned.
<br><br>The triplets will be added at the start of the existing waveform.  If
they are to start offset from the start then the first triplet should
consist solely of a delay i.e. 0 0 offset.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvag&nbsp;0x10&nbsp;0x80&nbsp;1000&nbsp;0x80&nbsp;0x10&nbsp;9000<br>2<br><br>$&nbsp;pigs&nbsp;wvag&nbsp;0&nbsp;0&nbsp;10000&nbsp;0x10&nbsp;0x80&nbsp;1000&nbsp;0x80&nbsp;0x10&nbsp;9000<br>4<br></code><h3><a name="WVAS">WVAS</a>
 <a href="#u">u</a> <a href="#b">b</a> <a href="#db">db</a> <a href="#sb">sb</a> <a href="#o">o</a> <a href="#bvs">bvs</a> - Add serial data to waveform</h3>This command adds a waveform representing serial data <a href="#bvs">bvs</a> to
GPIO <a href="#u">u</a> at <a href="#b">b</a> baud to the existing waveform (if any).
The serial data starts <a href="#o">o</a> microseconds from the start of the
waveform.
<br><br>Upon success the total number of pulses in the waveform so far is
returned.  On error a negative status code will be returned.
<br><br>The serial data is formatted as one start bit, <a href="#db">db</a> data bits, and
<a href="#sb">sb</a>/2 stop bits.
<br><br>The baud rate may be between 50 and 1000000 bits per second.
<br><br>It is legal to add serial data streams with different baud rates to
the same waveform.
<br><br>The bytes required for each character depend upon <a href="#db">db</a>.
<br><br>For <a href="#db">db</a> 1-8 there will be one byte per character.<br>
For <a href="#db">db</a> 9-16 there will be two bytes per character.<br>
For <a href="#db">db</a> 17-32 there will be four bytes per character.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvas&nbsp;4&nbsp;9600&nbsp;8&nbsp;2&nbsp;0&nbsp;0x30&nbsp;0x31&nbsp;0x32&nbsp;0x33<br>23<br><br>$&nbsp;pigs&nbsp;wvas&nbsp;7&nbsp;38400&nbsp;8&nbsp;2&nbsp;0&nbsp;0x41&nbsp;0x42<br>35<br></code><h3><a name="WVTAT">WVTAT</a>
 - Returns the current transmitting waveform</h3>This command returns the id of the waveform currently
being transmitted.
<br><br>Returns the waveform id or one of the following special
values:
<br><br>9998 - transmitted wave not found<br>
9999 - no wave being transmitted
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvtat<br>9999<br></code><h3><a name="WVBSY">WVBSY</a>
 - Check if waveform is being transmitted</h3>This command checks to see if a waveform is currently being transmitted.
<br><br>Returns 1 if a waveform is currently being transmitted, otherwise 0.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvbsy<br>0<br></code><h3><a name="WVCHA">WVCHA</a>
 <a href="#bvs">bvs</a> - Transmits a chain of waveforms</h3>This command transmits a chain of waveforms.
<br><br>NOTE: Any hardware PWM started by <a href="#HP">HP</a> will
be cancelled.
<br><br>The waves to be transmitted are specified by the contents of
<a href="#bvs">bvs</a> which contains an ordered list of wave_ids and optional
command codes and related data.
<br><br>Upon success 0 is returned.  On error a negative status code
will be returned.
<br><br>Each wave is transmitted in the order specified.  A wave may
occur multiple times per chain.
<br><br>A blocks of waves may be transmitted multiple times by using
the loop commands. The block is bracketed by loop start and
end commands.  Loops may be nested.
<br><br>Delays between waves may be added with the delay command.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>Loop Start</td><td>255 0</td><td>Identify start of a wave block</td></tr><tr><td>Loop Repeat</td><td>255 1 x y</td><td>loop x + y*256 times</td></tr><tr><td>Delay</td><td>255 2 x y</td><td>delay x + y*256 microseconds</td></tr><tr><td>Loop Forever</td><td>255 3</td><td>loop forever</td></tr></tbody></table><br><br>If present Loop Forever must be the last entry in the chain.
<br><br>The code is currently dimensioned to support a chain with roughly
600 entries and 20 loop counters.
<br><br><b><small>Example</small></b><br><br><code>#!/bin/bash<br><br>GPIO=4<br>WAVES=5<br><br>pigs&nbsp;m&nbsp;$GPIO&nbsp;w<br><br>for&nbsp;((i=0;&nbsp;i&lt;$WAVES;&nbsp;i++))<br>do<br>&nbsp;&nbsp;&nbsp;pigs&nbsp;wvag&nbsp;$((1&lt;&lt;GPIO))&nbsp;0&nbsp;20&nbsp;0&nbsp;$((1&lt;&lt;GPIO))&nbsp;$(((i+1)*200))<br>&nbsp;&nbsp;&nbsp;w[i]=$(pigs&nbsp;wvcre)<br>done<br><br>#&nbsp;transmit&nbsp;waves&nbsp;4+3+2<br>#&nbsp;loop&nbsp;start<br>#&nbsp;&nbsp;&nbsp;&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br>#&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;start<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transmit&nbsp;waves&nbsp;0+1<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay&nbsp;5000us<br>#&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;30&nbsp;times)<br>#&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;start<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transmit&nbsp;waves&nbsp;2+3+0<br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transmit&nbsp;waves&nbsp;3+1+2<br>#&nbsp;&nbsp;&nbsp;&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;10&nbsp;times)<br>#&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;5&nbsp;times)<br>#&nbsp;transmit&nbsp;waves&nbsp;4+4+4<br>#&nbsp;delay&nbsp;20000us<br>#&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br><br>pigs&nbsp;wvcha&nbsp;\<br>&nbsp;&nbsp;&nbsp;${w[4]}&nbsp;${w[3]}&nbsp;${w[2]}&nbsp;\<br>&nbsp;&nbsp;&nbsp;255&nbsp;0&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${w[0]}&nbsp;${w[0]}&nbsp;${w[0]}&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255&nbsp;0&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${w[0]}&nbsp;${w[1]}&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255&nbsp;2&nbsp;0x88&nbsp;0x13&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255&nbsp;1&nbsp;30&nbsp;0&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255&nbsp;0&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${w[2]}&nbsp;${w[3]}&nbsp;${w[0]}&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${w[3]}&nbsp;${w[1]}&nbsp;${w[2]}&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255&nbsp;1&nbsp;10&nbsp;0&nbsp;\<br>&nbsp;&nbsp;&nbsp;255&nbsp;1&nbsp;5&nbsp;0&nbsp;\<br>&nbsp;&nbsp;&nbsp;${w[4]}&nbsp;${w[4]}&nbsp;${w[4]}&nbsp;\<br>&nbsp;&nbsp;&nbsp;255&nbsp;2&nbsp;0x20&nbsp;0x4E&nbsp;\<br>&nbsp;&nbsp;&nbsp;${w[0]}&nbsp;${w[0]}&nbsp;${w[0]}<br><br>while&nbsp;[[&nbsp;$(pigs&nbsp;wvbsy)&nbsp;-eq&nbsp;1&nbsp;]];&nbsp;do&nbsp;sleep&nbsp;0.1;&nbsp;done<br><br>for&nbsp;((i=0;&nbsp;i&lt;$WAVES;&nbsp;i++));&nbsp;do&nbsp;echo&nbsp;${w[i]};&nbsp;pigs&nbsp;wvdel&nbsp;${w[i]};&nbsp;done<br></code><h3><a name="WVCLR">WVCLR</a>
 - Clear all waveforms</h3>This command clears all waveforms.
<br><br>Nothing is returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvclr<br></code><h3><a name="WVCRE">WVCRE</a>
 - Create a waveform</h3>This command creates a waveform from the data provided by the prior
calls to the <a href="#WVAG">WVAG</a> and <a href="#WVAS">WVAS</a> commands.
<br><br>Upon success a wave id (&gt;=0) is returned.  On error a negative status
code will be returned.
<br><br>The data provided by the <a href="#WVAG">WVAG</a> and <a href="#WVAS">WVAS</a> commands is
consumed by this command.
<br><br>As many waveforms may be created as there is space available.
The wave id is passed to <a href="#WVTX">WVTX</a> or <a href="#WVTXR">WVTXR</a> to specify the
waveform to transmit.
<br><br>Normal usage would be
<br><br>Step 1. <a href="#WVCLR">WVCLR</a> to clear all waveforms and added data.
<br><br>Step 2. <a href="#WVAG">WVAG</a>/<a href="#WVAS">WVAS</a> calls to supply the waveform data.
<br><br>Step 3. <a href="#WVCRE">WVCRE</a> to create the waveform and get a unique id.
<br><br>Repeat steps 2 and 3 as needed.
<br><br>Step 4. <a href="#WVTX">WVTX</a> or <a href="#WVTXR">WVTXR</a> with the id of the waveform to transmit.
<br><br>A waveform comprises of one or more pulses.
<br><br>A pulse specifies
<br><br>1) the GPIO to be switched on at the start of the pulse.<br>
2) the GPIO to be switched off at the start of the pulse.<br>
3) the delay in microseconds before the next pulse.
<br><br>Any or all the fields can be zero.  It doesn't make any sense to
set all the fields to zero (the pulse will be ignored).
<br><br>When a waveform is started each pulse is executed in order with
the specified delay between the pulse and the next.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvas&nbsp;4&nbsp;9600&nbsp;0&nbsp;23&nbsp;45&nbsp;67&nbsp;89&nbsp;90<br>37<br>$&nbsp;pigs&nbsp;wvcre<br>0<br><br>$&nbsp;pigs&nbsp;wvcre<br>-69<br>ERROR:&nbsp;attempt&nbsp;to&nbsp;create&nbsp;an&nbsp;empty&nbsp;waveform<br></code><h3><a name="WVCAP">WVCAP</a>
 - Create a waveform of fixed size</h3>Similar to WVCRE, this command creates a waveform but pads the consumed
resources to a fixed size, specified as a percent of total resource.
Padded waves of equal size can be re-cycled efficiently allowing newly
created waves to re-use the resources of deleted waves of the same dimension.
<br><br>Upon success a wave id (&gt;=0) is returned.  On error a negative status
code will be returned.
<br><br>The data provided by the <a href="#WVAG">WVAG</a> and <a href="#WVAS">WVAS</a> commands are
consumed by this command.
<br><br>As many waveforms may be created as there is space available.
The wave id is passed to <a href="#WVTX">WVTX</a> or <a href="#WVTXR">WVTXR</a> to specify the
waveform to transmit.
<br><br>Normal usage would be
<br><br>Step 1. <a href="#WVCLR">WVCLR</a> to clear all waveforms and added data.
<br><br>Step 2. <a href="#WVAG">WVAG</a>/<a href="#WVAS">WVAS</a> calls to supply the waveform data.
<br><br>Step 3. <a href="#WVCAP">WVCAP</a> to create a waveform of a uniform size.
<br><br>Step 4. <a href="#WVTX">WVTX</a> or <a href="#WVTXR">WVTXR</a> with the id of the waveform to transmit.
<br><br>Repeat steps 2 - 4 as needed.
<br><br>Step 5. Any wave id can now be deleted and another wave of the same size
        can be created in its place.
<br><br><b><small>Example</small></b><br><br><code>#&nbsp;Create&nbsp;a&nbsp;wave&nbsp;that&nbsp;consumes&nbsp;50%&nbsp;of&nbsp;the&nbsp;total&nbsp;resource:<br><br>$&nbsp;pigs&nbsp;wvag&nbsp;16&nbsp;0&nbsp;5000000&nbsp;0&nbsp;16&nbsp;5000000<br>2<br>$&nbsp;pigs&nbsp;wvcap&nbsp;50<br>0<br>$&nbsp;pigs&nbsp;wvtx&nbsp;0<br>11918<br></code><h3><a name="WVDEL">WVDEL</a>
 <a href="#wid">wid</a> - Delete selected waveform</h3>This command deletes the waveform with id <a href="#wid">wid</a>.
<br><br>The wave is flagged for deletion.  The resources used by the wave
will only be reused when either of the following apply.
<br><br>- all waves with higher numbered wave ids have been deleted or have
been flagged for deletion.
<br><br>- a new wave is created which uses exactly the same resources as
the current wave (see the C source for gpioWaveCreate for details).
<br><br>Upon success nothing is returned.  On error a negative status code
will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvdel&nbsp;0<br><br>$&nbsp;pigs&nbsp;wvdel&nbsp;0<br>-66<br>ERROR:&nbsp;non&nbsp;existent&nbsp;wave&nbsp;id<br></code><h3><a name="WVHLT">WVHLT</a>
 - Stop waveform</h3>This command aborts the transmission of the current waveform.
<br><br>Nothing is returned.
<br><br>This command is intended to stop a waveform started in the repeat mode.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvhlt<br></code><h3><a name="WVNEW">WVNEW</a>
 - Initialise a new waveform</h3>This clears any existing waveform data ready for the creation of a new
waveform.
<br><br>Nothing is returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvnew<br></code><h3><a name="WVSC">WVSC</a>
 <a href="#ws">ws</a> - Get waveform DMA CB stats</h3>The statistic requested by <a href="#ws">ws</a> is returned.
<br><br><a href="#ws">ws</a> identifies the subcommand as follows.
<br><br>0 Get Cbs<br>
1 Get High Cbs<br>
2 Get Max Cbs
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvas&nbsp;4&nbsp;9600&nbsp;0&nbsp;23&nbsp;45&nbsp;67&nbsp;89&nbsp;90<br>37<br><br>$&nbsp;pigs&nbsp;wvsc&nbsp;0<br>74<br>$&nbsp;pigs&nbsp;wvsc&nbsp;1<br>74<br>$&nbsp;pigs&nbsp;wvsc&nbsp;2<br>25016<br></code><h3><a name="WVSM">WVSM</a>
 <a href="#ws">ws</a> - Get waveform time stats</h3>The statistic requested by <a href="#ws">ws</a> is returned.
<br><br><a href="#ws">ws</a> identifies the subcommand as follows.
<br><br>0 Get Micros<br>
1 Get High Micros<br>
2 Get Max Micros
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvsm&nbsp;0<br>5314<br>$&nbsp;pigs&nbsp;wvsm&nbsp;1<br>5314<br>$&nbsp;pigs&nbsp;wvsm&nbsp;2<br>1800000000<br></code><h3><a name="WVSP">WVSP</a>
 <a href="#ws">ws</a> - Get waveform pulse stats</h3>The statistic requested by <a href="#ws">ws</a> is returned.
<br><br><a href="#ws">ws</a> identifies the subcommand as follows.
<br><br>0 Get Pulses<br>
1 Get High Pulses<br>
2 Get Max Pulses
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvsp&nbsp;0<br>37<br>$&nbsp;pigs&nbsp;wvsp&nbsp;1<br>37<br>$&nbsp;pigs&nbsp;wvsp&nbsp;2<br>12000<br></code><h3><a name="WVTX">WVTX</a>
 <a href="#wid">wid</a> - Transmits waveform once</h3>This command transmits the waveform with id <a href="#wid">wid</a> once.
<br><br>NOTE: Any hardware PWM started by <a href="#HP">HP</a> will be cancelled.
<br><br>Upon success the number of DMA control blocks in the waveform is returned.
On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvtx&nbsp;1<br>75<br><br>$&nbsp;pigs&nbsp;wvtx&nbsp;2<br>-66<br>ERROR:&nbsp;non&nbsp;existent&nbsp;wave&nbsp;id<br></code><h3><a name="WVTXM">WVTXM</a>
 <a href="#wid">wid</a> <a href="#wmde">wmde</a> - Transmits waveform using mode</h3>This command transmits the waveform with id <a href="#wid">wid</a> using mode <a href="#wmde">wmde</a>.
<br><br>The mode may be send once (0), send repeatedly (1), send once but
first sync with previous wave (2), or send repeatedly but first
sync with previous wave (3).
<br><br>WARNING: bad things may happen if you delete the previous
waveform before it has been synced to the new waveform.
<br><br>NOTE: Any hardware PWM started by <a href="#HP">HP</a> will be cancelled.
<br><br>Upon success the number of DMA control blocks in the waveform is returned.
On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvtxm&nbsp;1&nbsp;3<br>75<br><br>$&nbsp;pigs&nbsp;wvtxm&nbsp;2&nbsp;0<br>-66<br>ERROR:&nbsp;non&nbsp;existent&nbsp;wave&nbsp;id<br></code><h3><a name="WVTXR">WVTXR</a>
 <a href="#wid">wid</a> - Transmits waveform repeatedly</h3>This command transmits the waveform with id <a href="#wid">wid</a> repeatedly.
<br><br>NOTE: Any hardware PWM started by <a href="#HP">HP</a> will be cancelled.
<br><br>Upon success the number of DMA control blocks in the waveform is returned.
On error a negative status code will be returned.
<br><br><b><small>Example</small></b><br><br><code>$&nbsp;pigs&nbsp;wvtxr&nbsp;1<br>75<br><br>$&nbsp;pigs&nbsp;wvtxr&nbsp;2<br>-66<br>ERROR:&nbsp;non&nbsp;existent&nbsp;wave&nbsp;id<br></code><h2><a name="Parameters">Parameters</a></h2>
<h3><a name="actv">actv</a> - 0-1000000</h3>
The number of microseconds level changes are reported for once
a noise filter has been triggered (by <a href="#stdy">stdy</a> microseconds of
a stable level).
<h3><a name="b">b</a> - baud</h3>
The command expects the baud rate in bits per second for
the transmission of serial data (I2C/SPI/serial link, waves).
<h3><a name="bctl">bctl</a> - BSC control word</h3>
The command expects a BSC control word, see <a href="#BSCX">BSCX</a>.
<h3><a name="bit">bit</a> - bit value (0-1)</h3>
The command expects 0 or 1.
<h3><a name="bits">bits</a> - a bit mask</h3>
A mask is used to select one or more GPIO.  A GPIO is selected
if bit (1&lt;&lt;GPIO) is set in the mask.
<br><br>E.g. a mask of 6 (binary 110) select GPIO 1 and 2, a mask of
0x103 (binary 100000011) selects GPIO 0, 1, and 8.
<h3><a name="bv">bv</a> - a byte value (0-255)</h3>
The command expects a byte value.
<h3><a name="bvs">bvs</a> - byte values (0-255)</h3>
The command expects one or more byte values.
<h3><a name="c">c</a> - SPI channel (0-1)</h3>
The command expects a SPI channel.
<h3><a name="cf">cf</a> - hardware clock frequency (4689-250M, 13184-375M for the BCM2711)</h3>
The command expects a frequency.
<h3><a name="cs">cs</a> - GPIO (0-31)</h3>
The GPIO used for the slave select signal when bit banging SPI.
<h3><a name="db">db</a> - serial data bits (1-32)</h3>
The command expects the number of data bits per serial character.
<h3><a name="dev">dev</a> - a tty serial device (/dev/tty* or /dev/serial*)</h3>
The command expects the name of a tty serial device, e.g.
<br><br><code>/dev/ttyAMA0<br>/dev/ttyUSB0<br>/dev/tty0<br>/dev/serial0<br></code><h3><a name="event">event</a> - 0-31</h3>
An event is a signal used to inform one or more consumers
to start an action.
<h3><a name="file">file</a> - a file name</h3>
The file name must match an entry in /opt/pigpio/access.
<h3><a name="from">from</a> - 0-2</h3>
Position to seek from <a href="#FS">FS</a>.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>From</td></tr><tr><td>0</td><td>start</td></tr><tr><td>1</td><td>current position</td></tr><tr><td>2</td><td>end</td></tr></tbody></table><h3><a name="g">g</a> - GPIO (0-53)</h3>
The command expects a GPIO.
<br><br>There are 54 General Purpose Input Outputs (GPIO) named gpio0 through gpio53.
<br><br>They are split into two banks.  Bank 1 consists of gpio0 through gpio31.
Bank 2 consists of gpio32 through gpio53.
<br><br>All the GPIO which are safe for the user to read and write are in bank 1.
Not all GPIO in bank 1 are safe though. Type 1 boards have 17 safe GPIO.
Type 2 boards have 21. Type 3 boards have 26.
<br><br>See <a href="#HWVER">HWVER</a>.
<br><br>The user GPIO are marked with an X in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr><tr><td>Type 1</td><td>X</td><td>X</td><td>-</td><td>-</td><td>X</td><td>-</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>-</td><td>X</td><td>X</td></tr><tr><td>Type 2</td><td>-</td><td>-</td><td>X</td><td>X</td><td>X</td><td>-</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>-</td><td>X</td><td>X</td></tr><tr><td>Type 3</td><td></td><td></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>31</td></tr><tr><td>Type 1</td><td>-</td><td>X</td><td>X</td><td>-</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Type 2</td><td>-</td><td>X</td><td>X</td><td>-</td><td>-</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>Type 3</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><br><br>You are not prevented from writing to unsafe GPIO.  The consequences
of doing so range from no effect, to a crash, or corrupted data.
<h3><a name="h">h</a> - handle (&gt;=0)</h3>
The command expects a handle.
<br><br>A handle is a number referencing an object opened by one of <a href="#FO">FO</a>,
<a href="#I2CO">I2CO</a>, <a href="#NO">NO</a>, <a href="#SERO">SERO</a>, <a href="#SPIO">SPIO</a>.
<h3><a name="ib">ib</a> - I2C bus (&gt;=0)</h3>
The command expects an I2C bus number.
<h3><a name="id">id</a> - I2C device (0-0x7F)</h3>
The command expects the address of an I2C device.
<h3><a name="if">if</a> - I2C flags (0)</h3>
The command expects an I2C flags value.  No flags are currently defined.
<h3><a name="L">L</a> - level (0-1)</h3>
The command expects a GPIO level.
<h3><a name="m">m</a> - mode (RW540123)</h3>
The command expects a mode character.
<br><br>Each GPIO can be configured to be in one of 8 different modes. The modes
are named Input, Output, ALT0, ALT1, ALT2, ALT3, ALT4, and ALT5.
<br><br>To set the mode use the code for the mode.
<br><br>The value is returned by the mode get command.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Mode</td><td>Input</td><td>Output</td><td>ALT0</td><td>ALT1</td><td>ALT2</td><td>ALT3</td><td>ALT4</td><td>ALT5</td></tr><tr><td>Code</td><td>R</td><td>W</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>Value</td><td>0</td><td>1</td><td>4</td><td>5</td><td>6</td><td>7</td><td>3</td><td>2</td></tr></tbody></table><h3><a name="miso">miso</a> - GPIO (0-31)</h3>
The GPIO used for the MISO signal when bit banging SPI.
<h3><a name="mode">mode</a> - file open mode</h3>
One of the following values.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>Value</td><td>Meaning</td></tr><tr><td>READ</td><td>1</td><td>open file for reading</td></tr><tr><td>WRITE</td><td>2</td><td>open file for writing</td></tr><tr><td>RW</td><td>3</td><td>open file for reading and writing</td></tr></tbody></table><br><br>The following values can be or'd into the mode.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>Value</td><td>Meaning</td></tr><tr><td>APPEND</td><td>4</td><td>All writes append data to the end of the file</td></tr><tr><td>CREATE</td><td>8</td><td>The file is created if it doesn't exist</td></tr><tr><td>TRUNC</td><td>16</td><td>The file is truncated</td></tr></tbody></table><h3><a name="mosi">mosi</a> - GPIO (0-31)</h3>
The GPIO used for the MOSI signal when bit banging SPI.
<h3><a name="name">name</a> - the name of a script</h3>
Only alphanumeric characters, '-' and '_' are allowed in the name.
<h3><a name="num">num</a> - maximum number of bytes to return (1-)</h3>
The command expects the maximum number of bytes to return.
<br><br>For the I2C and SPI commands the requested number of bytes will always
be returned.
<br><br>For the serial and file commands the smaller of the number of
bytes available to be read (which may be zero) and <a href="#num">num</a> bytes
will be returned.
<h3><a name="o">o</a> - offset (&gt;=0)</h3>
Serial data is stored offset microseconds from the start of the waveform.
<h3><a name="p">p</a> - PUD (ODU)</h3>
The command expects a PUD character.
<br><br>Each GPIO can be configured to use or not use an internal pull up or
pull down resistor.  This is useful to provide a default state for inputs.
<br><br>A pull up will default the input to 1 (high).
<br><br>A pull down will default the input to 0 (low).
<br><br>To set the pull up down state use the command character for the state.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pull Up Down</td><td>Off</td><td>Pull Down</td><td>Pull Up</td></tr><tr><td>Command Character</td><td>O</td><td>D</td><td>U</td></tr></tbody></table><br><br>There is no mechanism to read the pull up down state.
<h3><a name="pad">pad</a> - 0-2</h3>
A set of GPIO which share common drivers.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><h3><a name="padma">padma</a> - 1-16</h3>
The mA which may be drawn from each GPIO whilst still guaranteeing the
high and low levels.
<h3><a name="pars">pars</a> - script parameters</h3>
The command expects 0 to 10 numbers as parameters to be passed to the script.
<h3><a name="pat">pat</a> - a file name pattern</h3>
A file path which may contain wildcards.  To be accessible the path
must match an entry in /opt/pigpio/access.
<h3><a name="pdc">pdc</a> - hardware PWM dutycycle (0-1000000)</h3>
The command expects a dutycycle.
<h3><a name="pf">pf</a> - hardware PWM frequency (1-125M, 1-187.5M for the BCM2711)</h3>
The command expects a frequency.
<h3><a name="pl">pl</a> - pulse length (1-100)</h3>
The command expects a pulse length in microseconds.
<h3><a name="r">r</a> - register (0-255)</h3>
The command expects an I2C register number.
<h3><a name="sb">sb</a> - serial stop (half) bits (2-8)</h3>
The command expects the number of stop (half) bits per serial character.
<h3><a name="scl">scl</a> - user GPIO (0-31)</h3>
The command expects the number of the GPIO to be used for SCL
when bit banging I2C.
<h3><a name="sclk">sclk</a> - user GPIO (0-31)</h3>
The GPIO used for the SCLK signal when bit banging SPI.
<h3><a name="sda">sda</a> - user GPIO (0-31)</h3>
The command expects the number of the GPIO to be used for SDA
when bit banging I2C.
<h3><a name="sef">sef</a> - serial flags (32 bits)</h3>
The command expects a flag value.  No serial flags are currently defined.
<h3><a name="sid">sid</a> - script id (&gt;= 0)</h3>
The command expects a script id as returned by a call to <a href="#PROC">PROC</a>.
<h3><a name="spf">spf</a> - SPI flags (32 bits)</h3>
See <a href="#SPIO">SPIO</a> and <a href="#BSPIO">BSPIO</a>.
<h3><a name="stdy">stdy</a> - 0-300000</h3>
The number of microseconds level changes must be stable for
before reporting the level changed (<a href="#FG">FG</a>) or triggering
the active part of a noise filter (<a href="#FN">FN</a>).
<h3><a name="str">str</a> - a string</h3>
The command expects a string.
<h3><a name="t">t</a> - a string</h3>
The command expects a string.
<h3><a name="trips">trips</a> - triplets</h3>
The command expects 1 or more triplets of GPIO on, GPIO off, delay.
<br><br>E.g. 0x400000 0 100000 0 0x400000 900000 defines two pulses as follows
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>GPIO on</td><td>GPIO off</td><td>delay</td></tr><tr><td>0x400000 (GPIO 22)</td><td>0 (None)</td><td>100000 (1/10th s)</td></tr><tr><td>0 (None)</td><td>0x400000 (GPIO 22)</td><td>900000 (9/10th s)</td></tr></tbody></table><h3><a name="u">u</a> - user GPIO (0-31)</h3>
The command expects the number of a user GPIO.
<br><br>A number of commands are restricted to GPIO in bank 1,
in particular the PWM commands, the servo command,
the watchdog command, and the notification command.
<br><br>It is your responsibility to ensure that the PWM and servo commands
are only used on safe GPIO.
<br><br>See <a href="#g">g</a>
<h3><a name="uvs">uvs</a> - values</h3>
The command expects an arbitrary number of &gt;=0 values (possibly none).
Any after the first two must be &lt;= 255.
<h3><a name="v">v</a> - value</h3>
The command expects a number.
<h3><a name="wid">wid</a> - wave id (&gt;=0)</h3>
The command expects a wave id.
<br><br>When a waveform is created it is given an id (0, 1, 2, ...).
<h3><a name="wmde">wmde</a> - mode (0-3)</h3>
The command expects a wave transmission mode.
<br><br>0 = send once<br>
1 = send repeatedly<br>
2 = send once but first sync with previous wave<br>
3 = send repeatedly but first sync with previous wave<br>
<h3><a name="ws">ws</a> - wave stats sucommand (0-2)</h3>
The command expects a subcommand.
<br><br>0 = current value.<br>
1 = highest value so far.<br>
2 = maximum possible value.
<h3><a name="wv">wv</a> - word value (0-65535)</h3>
The command expects a word value.
<h2><a name="Scripts">Scripts</a></h2>
Scripts are programs to be stored and executed by the pigpio daemon.
They are intended to mitigate any performance problems associated with
the pigpio daemon server/client model.
<h3>Example</h3>A trivial example might be useful.  Suppose you want to toggle a GPIO
on and off as fast as possible.
<br><br>From the command line you could write
<br><br><code>for&nbsp;((i=0;&nbsp;i&lt;1000;i++));&nbsp;do&nbsp;pigs&nbsp;w&nbsp;22&nbsp;1&nbsp;w&nbsp;22&nbsp;0;&nbsp;done<br></code><br><br>Timing that you will see it takes about 14 seconds, or roughly
70 toggles per second.
<br><br>Using the pigpio Python module you could use code such as
<br><br><code>#!/usr/bin/env&nbsp;python<br><br>import&nbsp;time<br><br>import&nbsp;pigpio<br><br>PIN=4<br><br>TOGGLE=10000<br><br>pi&nbsp;=&nbsp;pigpio.pi()&nbsp;#&nbsp;Connect&nbsp;to&nbsp;local&nbsp;Pi.<br><br>s&nbsp;=&nbsp;time.time()<br><br>for&nbsp;i&nbsp;in&nbsp;range(TOGGLE):<br>&nbsp;&nbsp;&nbsp;pi.write(PIN,&nbsp;1)<br>&nbsp;&nbsp;&nbsp;pi.write(PIN,&nbsp;0)<br><br>e&nbsp;=&nbsp;time.time()<br><br>print("pigpio&nbsp;did&nbsp;{}&nbsp;toggles&nbsp;per&nbsp;second".format(int(TOGGLE/(e-s))))<br><br>pi.stop()<br></code><br><br>Timing that shows a speed improvement to roughly 800 toggles per second.
<br><br>Now let's use a script.
<br><br><code>pigs&nbsp;proc&nbsp;tag&nbsp;999&nbsp;w&nbsp;22&nbsp;1&nbsp;w&nbsp;22&nbsp;0&nbsp;dcr&nbsp;p0&nbsp;jp&nbsp;999<br></code><br><br>Ignore the details for now.
<br><br>Let's time the script running.
<br><br>Again, ignore the details for now.
<br><br><code>time&nbsp;(pigs&nbsp;procr&nbsp;0&nbsp;10000000;&nbsp;while&nbsp;a=$(pigs&nbsp;procp&nbsp;0);&nbsp;[[&nbsp;${a::1}&nbsp;-eq&nbsp;2&nbsp;]];\<br>&nbsp;do&nbsp;sleep&nbsp;0.2;&nbsp;done)<br></code><br><br>The script takes roughly 12 seconds to complete, or 800,000 toggles per second.
<br><br>That is the advantage of a stored script.
<br><br>Some details.
<br><br><code>pigs&nbsp;proc&nbsp;tag&nbsp;999&nbsp;w&nbsp;22&nbsp;1&nbsp;w&nbsp;22&nbsp;0&nbsp;dcr&nbsp;p0&nbsp;jp&nbsp;999<br></code><br><br>proc introduces a script.  Everything after proc is part of the script.<br>
tag 999 names the current position in the script.<br>
w 22 1 writes 1 to GPIO 22.<br>
w 22 0 writes 0 to GPIO 22.<br>
dcr p0 decrements parameter 0.<br>
jp 999 jumps to tag 999 if the result is positive.
<br><br><code>time&nbsp;(pigs&nbsp;procr&nbsp;0&nbsp;10000000;&nbsp;while&nbsp;a=$(pigs&nbsp;procp&nbsp;0);&nbsp;[[&nbsp;${a::1}&nbsp;-eq&nbsp;2&nbsp;]];\<br>&nbsp;do&nbsp;sleep&nbsp;0.2;&nbsp;done)<br></code><br><br>pigs procr 0 10000000 starts script 0 with parameter 0 of 10 million.
<br><br>The rest is bash apart from
<br><br>pigs procp 0 asks for the status and parameters of script 0.
The status will be 2 while the script is running and 1 when it is complete.
<h3>Virtual machine</h3>A script runs within a virtual machine with
<br><br>a 32 bit accumulator A.<br>
a flags register F.<br>
a program counter PC.
<br><br>Each script has
<br><br>10 parameters named 0 through 9.<br>
150 variables named 0 through 149.<br>
50 labels which are named by any unique number.
<h3>Commands</h3>Many pigpio commands may be used within a script.  However
some commands do not work within the script model as designed and
are not permitted.
<br><br>The following commands are not permitted within a script:
<br><br>File - FL FO FR FW
<br><br>I2C - BI2CZ I2CPK I2CRD I2CRI I2CRK I2CWD I2CWI I2CWK I2CZ
<br><br>Misc - BSCX CF1 CF2 SHELL
<br><br>Script control - PARSE PROC PROCD PROCP PROCR PROCS PROCU
<br><br>Serial - SERO SERR SERW SLR
<br><br>SPI - BSPIO BSPIX SPIR SPIW SPIX
<br><br>Waves - WVAG WVAS WVCHA WVGO WVGOR
<br><br>The following commands are only permitted within a script:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Command</td><td>Description</td><td>Definition</td></tr><tr><td>ADD x</td><td>Add x to accumulator</td><td>A+=x; F=A</td></tr><tr><td>AND x</td><td>And x with accumulator</td><td>A&=x; F=A</td></tr><tr><td>CALL L</td><td>Call subroutine at tag L</td><td>push(PC+1); PC=L</td></tr><tr><td>CMP x</td><td>Compare x with accumulator</td><td>F=A-x</td></tr><tr><td>DCR y</td><td>Decrement register</td><td>--*y; F=*y</td></tr><tr><td>DCRA</td><td>Decrement accumulator</td><td>--A; F=A</td></tr><tr><td>DIV x</td><td>Divide x into accumulator</td><td>A/=x; F=A</td></tr><tr><td>EVTWT</td><td>Wait for an event to occur</td><td>A=wait(x); F=A</td></tr><tr><td>HALT</td><td>Halt</td><td>Halt</td></tr><tr><td>INR y</td><td>Increment register</td><td>++*y; F=*y</td></tr><tr><td>INRA</td><td>Increment accumulator</td><td>++A; F=A</td></tr><tr><td>JM L</td><td>Jump if minus to tag L</td><td>if (F&lt;0) PC=L</td></tr><tr><td>JMP L</td><td>Jump to tag L</td><td>PC=L</td></tr><tr><td>JNZ L</td><td>Jump if non-zero to tag L</td><td>if (F) PC=L</td></tr><tr><td>JP L</td><td>Jump if positive to tag L</td><td>if (F&gt;=0) PC=L</td></tr><tr><td>JZ L</td><td>Jump if zero to tag L</td><td>if (!F) PC=L</td></tr><tr><td>LD y x</td><td>Load register with x</td><td>*y=x</td></tr><tr><td>LDA x</td><td>Load accumulator with x</td><td>A=x</td></tr><tr><td>MLT x</td><td>Multiply x with accumulator</td><td>A*=x; F=A</td></tr><tr><td>MOD x</td><td>Modulus x with accumulator</td><td>A%=x; F=A</td></tr><tr><td>OR x</td><td>Or x with accumulator</td><td>A|=x; F=A</td></tr><tr><td>POP y</td><td>Pop register</td><td>y=pop()</td></tr><tr><td>POPA</td><td>Pop accumulator</td><td>A=pop()</td></tr><tr><td>PUSH y</td><td>Push register</td><td>push(y)</td></tr><tr><td>PUSHA</td><td>Push accumulator</td><td>push(A)</td></tr><tr><td>RET</td><td>Return from subroutine</td><td>PC=pop()</td></tr><tr><td>RL y x</td><td>Rotate left register x bits</td><td>*y&lt;&lt;=x; F=*y</td></tr><tr><td>RLA x</td><td>Rotate left accumulator x bits</td><td>A&lt;&lt;=x; F=A</td></tr><tr><td>RR y x</td><td>Rotate right register x bits</td><td>*y&gt;&gt;=x; F=*y</td></tr><tr><td>RRA x</td><td>Rotate right accumulator x bits</td><td>A&gt;&gt;=x; F=A</td></tr><tr><td>STA y</td><td>Store accumulator in register</td><td>y=A</td></tr><tr><td>SUB x</td><td>Subtract x from accumulator</td><td>A-=x; F=A</td></tr><tr><td>SYS str</td><td>Run external script (/opt/pigpio/cgi/str)</td><td>system(str); F=A</td></tr><tr><td>TAG L</td><td>Label the current script position</td><td>N/A</td></tr><tr><td>WAIT x</td><td>Wait for a GPIO in x to change state</td><td>A=wait(x); F=A</td></tr><tr><td>X y1 y2</td><td>Exchange contents of registers y1 and y2</td><td>t=*y1;*y1=*y2;*y2=t</td></tr><tr><td>XA y</td><td>Exchange contents of accumulator and register</td><td>t=A;A=*y;*y=t</td></tr><tr><td>XOR x</td><td>Xor x with accumulator</td><td>A^=x; F=A</td></tr></tbody></table><br><br>x may be a constant, a parameter (p0-p9), or a variable (v0-v149).
<br><br>y may be a parameter (p0-p9), or a variable (v0-v149).  If p or v isn't
specified y is assumed to be a variable.
<br><br>The EVTWT command parameter is a bit-mask with 1 set for events of interest.
<br><br>The WAIT command parameter is a bit-mask with 1 set for GPIO of interest.
<br><br>The SYS script receives two unsigned parameters: the accumulator A and
the current GPIO levels.
<br><br></td>
</table>
<div style="vertical-align: center; text-align: center; background-color:#98bf21; font-size:0.8em; height:30px"><a class="l2" href="index.html">[pigpio]</a>
<a class="l2" href="cif.html">[pigpio C I/F]</a>
<a class="l2" href="pigpiod.html">[pigpiod]</a>
<a class="l2" href="pdif2.html">[pigpiod C I/F]</a>
<a class="l2" href="python.html">[Python]</a>
<a class="l2" href="pigs.html">[pigs]</a>
<a class="l2" href="piscope.html">[piscope]</a>
<a class="l2" href="misc.html">[Misc]</a>
<a class="l2" href="examples.html">[Examples]</a>
<a class="l2" href="download.html">[Download]</a>
<a class="l2" href="faq.html">[FAQ]</a>
<a class="l2" href="sitemap.html">[Site Map]</a>
</div>
<table><tr>
<td style="width: 200px"><div style="text-align: left;"><small>&copy; 2012-2020</small></div></td>
<td style="width: 350px"><div style="text-align: center;">e-mail: pigpio @ abyz.me.uk</div></td>
<td style="width: 200px"><div style="text-align: right;"><small>Updated: 29/04/2020</small></div></td>
</tr></table>
</td>
</table>
</body>
</html>
